// 2 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
NodeJS - платформа для взаимодейтсвия с помощью JavaScript, например, с файловой системой, с серверной частью (с помощью NodeJS и создается программа для сервера) и т.д.

Node.js — программная платформа, основанная на движке V8 (компилирующем JavaScript в машинный код), превращающая JavaScript из узкоспециализированного языка в язык 
общего назначения. Node.js добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API, написанный на C++, подключать другие внешние 
библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода.

NodeJS содержит в себе несколько различных написанных программ (пакетов), которые устанавливаются с помощью рабочей лошидки NodeJS - NPM (nodejs packages manager)
Для запуска таких программ существует другая рабочаяя лошадка - NPX.

// 3 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Установка - https://nodejs.org/en/download

// 4 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Открываем консоль NodeJS (command prompt) и открываем папку в которой будем создавать наш проект
По умолчанию консоль открыта на диске C. Чтобы сменить диск необходимо написать имя диска и двоеточие "d:" и нажать Enter

Теперь чтобы перейти в необходимую нам директорию (сменить её) необходимо написать cd (change directory) и указать путь к папке (директории)
Чтобы поднять на уровень выше (выйти из папки) необходимо написать "cd ..", а чтобы провалиться "cd имя-папки/имя-внутренней-папки" и т.д.

После установик пакета запустить проект с помощью npm start не получится т.к. мы остались в предыдущей директории где лежит не сам проект (пакет)
а лишь папка с этим проектом, а значит нам необходимо провалиться в папку с проектом (там лежит package.json - набор настроек проекта, без которого
проект не запуститься)

// 5 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
JSX - это своегорода синтаксический сахар позволяющий писать HTML разметку внутри JavaScript кода
Один JavaScript файл (компонент) должен быть представлен либо функцией которая возвращает HTML разметку с помощью return с логикой внутри себя, 
либо класс с методом render(). Важно что родительский элемент должен быть только один (нельзя вернуть два и болле тега на первом уровне вложенности)


// 6 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
SPA - крутая концепция, т.к. позволяет не запращивать у сервера постоянно новый HTML документ при каждой перезагрузки страницы, а разово загрузить
страницу и отправлять с помощью большого количества JS подгруженного изначально AJAX-запросы серверу, в ответ на которые тот шлет JSON объекты с 
данными. Теперь если вам на странице с сообщениями (например в ВК) пришло новое сообщение, нет необходимости рендерить весь HTML документ заново.
Мы просто считываем данные с JSON (response) от сервера и отображаем их на странице. Таким образом SPA позволяет экономить ресурсы и компьютера и 
сервера одновременно.
Страница всегда одна даже если с раздела "Сообщения" необходимо перейти в раздел "Feed". Формально URL меняется, но запрашиваем мы не новый HTML,
а также данные JSON и просто заново отрисовываем первоначально загруженную страницу.

Также ввиду того, что на мобильной разработке приложений не используется HTML документы, мы не можем использовать обычный подход отправки страницы
целиком в браузере клиенту, т.к. этот сервер будет заточен под генерацию HTML, но когда мы используем в качестве обмена информацией JSON объекты,
то мы можем использовать один и тот же сервер и для мобильных приложений т.к. они способны отображать данные прочитанные из JSON

Картинка приложена к конспекту в папке 

// 7 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Компонент - это функция, возвращающая JSX разметку. Она может выполнять внутри себя логику и т.д. но обязательно должна вернуть JSX (содержание
которого может зависеть от логики внутри функции-компонента)

Компоненты можно вкладывать друг в друга, ведь они являются неким аналогом HTML-тега только уже в с вложенным контентом и другими тегами. Мы конечно
можем создать в одном файле App.js все компоненты сайта и объекдинить их в общую обертку, но тогда навигация по коду станет очень сложной, поэтому
каждую компоненту принято выносить в отдельный файл с таким же названием как и сама компонента

// 8 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Исходя из того, что каждый компонент имеет свой свобственный файл, эти файлы необходимо как-то связывать вместе. Соответственно теперь два компонента,
которые мы создавали в предыдущем уроке нам изначально необходимо вынести в отдельные файлы.

После вынесения в отдельные файлы всех компонентов, нам необходимо ими обмениваться. Для этого и существует import и export
Синтаксис следующий:

import lalala from 'path' 

lalala - название какой-то компоненты, которую мы будем использовать в данном коде
'path' - относительный путь (не абсолютный)
Относительный путь задается относительно того файлы в который мы импортируем. То есть находясь в файле App.js я задаю относительный путь для поиска
от данного файла. Чтобы остаться в этой же папке "./" для того чтобы выйти в родительскую "../"

export default lalala

lalala - название компонента (функции) который мы экспортируем из этого файла при необходимости импортировать где-то в другом месте.
(Для того чтобы файл понималь когда из него что-то хотят импортировать, что именно он должен отдать)

Для SomePart.js это - export default SomePart
Для Header.js это - export default Header

Соответственно теперь для подключения этих файлов в App.js необходимо их импортировать
import Header from './Header.js'
import SomePart from './SomePart.js'

// 10 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Когда мы импортируем какой-либо компонент мы задаем для него название после слова import. Соответственно есть шанс ошибиться и импортировать в 
переменную SomePart не компонент SomePart, а например, Header. Для того чтобы избежать такой ситуации мы должны задавать названия компонентам
строго в соответствии с их навзаниями в файлах из которых мы их экспортируем. 
Для того чтобы не использовать случайно компонент который забыли импортировать можно установить плагин "Auto import"

// 11 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Grid-верстка
grid-template-rows: 1fr 1fr;  -  задаем количество строк и их пропорциональное отношение (fr - фракция)
grid-template-columns: 1fr 5fr; задаем количество столбцов и их пропорциональное отношение (fr - фракция)

Каждому элементу который будем позиционировать относительно данной разметки необходимо задать собственное имя для grid разметки в css
.nav {
    grid-area: nav;
}
.content {
    grid-area: cont;
}
.header {
    grid-area: header;
}

После того как элементам дас помощью grid-area присвоено grid-название и создан шаблон таблицы с помощью grid-template-rows(columns)
необходимо расставить данные элементы в созданный шаблон с помощью grid-template-areas

.app-wrapper {
    display: grid;

    grid-template-rows: 60px 1fr;
    grid-template-columns: 1fr 5fr;

    grid-template-areas:
        'header header'
        'nav cont';
}

Шаблон из 4 ячеек 2х2 заполняется следующим образом:
                    1столбик   2столбик
    Первая строка - header     header
    Вторая строка - nav        cont

row-gap: 10px; - задает отступ между строк
column-gap: 10px; - задает отступ между столбцов

// 14 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке мы разбили общий файл с CSS свойствами на отдельные файлы (соответствующие компонентам) и подключили их к соответствующим компонентам. Такой подход кажется
удобным и функциональным т.к. у нас теперь нет огромного монолитного файла CSS-свойств, а есть отдельные файлы для описания свойств каждого отдельного компонента. 
Такой подход более читабельный и ускоряет навигацию между стилями. Однако есть одно существенное "но". Если мы зададим например классу 'item' свойства в файле Profile.jsx, 
то они применятся и к элементам с классом 'item' в других файлах, как например тут, к элементам файла Navigation.jsx

Подробно про этот процесс:
Если проинспектировать страницу проекта, то во вкладке Network можно заметить, что в браузер не приходит ни одного CSS файла. Т.к. все компоненты и стили к ним приходят 
одним монолитным JS-файлом под названием "bundle.js". Из этого файла все CSS стили вставляются в сам HTML-документ в тегах <style></style> в шапке страницы 
(в теге <head></head>) и там уже все эти стили имеют одинаковый уровень вложенности, а соответственно переназначают стили элементам с одинаковым названием селекторов. 
(Каждый одельный CSS файл для компонента - отдельный тег <style></style> и из этого следует, что стили будут переназначать по последнему добавленному файлу стилей 
компонента. Например, если у нас в header и в footer есть тег <nav></nav> и ему заданы свойства в CSS файлах соответствующих компонентов, то к nav внутри header применятся 
свойства nav в footer, т.к. тег <style></style> для footer добавится после тега <style></style> для header в <head></head> страницы) 

Для того чтобы избежать перетерания стилей необходимо в jsx файлы компонентов импортировать не просто .css файл, а module.css файл. Т.е. название файла navigation.css
нам необходимо переназначить на navigation.module.css. Теперь этот файл возращает объект со стилями и соответственно при импорте из этого файла мы должны обработать, 
возвращаемый объект каким-то образом.
Данный файл добавляет каждому селектору в соответствующем файле префикс и постфикс (которые означают имя компонента и уникалльный идентификатор который гарантированно
не будет повторяться в проекте). Т.е. .nav превращается в .Navigation_nav__1QeRT5

Navigation - название компонента
1QeRT5 - уникальный id

Соответственно, чтобы обработать и присвоить переписанные классы нам нужно обратиться к импортирорванному объекту который представлен в формате:
{
    'item': 'Navigation_item_qW34Sr',
    'nav': 'Navigation_nav__1QeRT5'
}
Соотвтественно для правильной обработки данного файла и правильного присваивания классов мы должны сделать следующее:
1. Правильно импортировать CSS-модуль (import NavigationStyles from "./Navigation.module.css";)
2. Соответствующим className элементов задать значение ={NavigationStyles.item} или ={NavigationStyles['item']}

Стили лучше задавать через обращение с помощью квадратных скобок [], т.к. некоторые названия включают символ "-" который не распознаётся JS и поэтому свойство объекта
(название класса) лучше передавать как строку в квадратных скобках или вместо "-" использовать нижнее подчеркивание "_"

После реализации данного подхода свойства перестают перетираться, т.к. теперь в нашем примере для ".item a" внутри Navigation.jsx задан класс ".Navigation_item_qW34Sr a", 
а для ".item a" внутри Profile.jsx задан просто класс ".item a"
С таким подходом необязательно использовать методологию БЭМ.
Теперь осталось закоментировать все console.log() и в Profile.jsx убрать тег <a></a> созданный там для показательного примера перетерания стилей

Для того чтобы добавлять несколько классов можно использовать шаблонные строки (обратные кавычки). 
Синтаксис следующий: {`${module.class} ${module.anotherClass}`}
Сначала добавляем в JSX выражение на JS с помощью обратных кавычек, а затем внутри них через пробел перечисляем необходимые классы

// 15 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Компоненты и их CSS модули лучше компоновать в отдельные папки с названием папки как у самого компонента.

// 16 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Чтобы в обычном JS изменять поведение функции необходимо внутри её логики обрабатывать передаваемые параметры. Так же это работает и для ReactJS.
Для того чтобы обрабатывать те или иные изменяемые параметры (свойства) мы передаем в функцию-компонент объект содержащий в качестве свойств
весь необходимый набор параметров. Этот объект называется "props".
Когда мы вызываем компонент без каких-либо дополнительных записей (например, просто <Header />), в него передается пустой объект props
Так как компонент ReactJS - это тег, а теги мы настраиваем через атрибуты, то соответственно мы можем настроить и передать какие-то данные
извне в компонент (передать данные из компонента-родителя компоненту-дочке). Соответственно если мы передаем какой-либо атрибут в компонент, то 
он добавляется в объект props и имя свойства - название атрибута, а его значение - значение атрибута.
Т.е. если вызываем:
<Header /> --------------> Props = {}
<Header name="Egor" age="23" /> --------------> Props = {
                                                            name: "Egor",
                                                            age: "23"
                                                        }
Для того, чтобы использовать передаваемые значение параметров внутри самого компонента используем:
1. Для JSX {props.atributeName}
2. Просто внутри функции props.atributeName

// 18 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке вынесем grid разметку для компонента Profile.jsx в тег <main></main> внутри App.js для того чтобы постоянно при изменении содержания блока content (в grid)
не записывать каждому компоненту свойство grid-area: content; 
Данное свойство просто задано обертке для компонентов в ячейке content

// 19 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Изначально, конечно ссылкам необходимо задать URL адрес запроса с помощью тега href="". Важно, что когда мы задаем данные адрес мы указываем путь относительно папки проекта 
и не ставим точки в данном пути, т.к. уже работаем не с файловой системой, как например, при импорте компонентов в проекте, а работаем с созданием запросов REST API, а там
точки не ставятся. То есть задаем href="/profile" (Это значит что "/profile" добавится к изначальному URL адресу) - для ссылки ведущей к компоненту Profile и аналогично с 
другими ссылками и компонентами для них.

Помимо этого, для того чтобы отображение содержимого страницы зависило от URL к которому мы обращаемся по ссылке (тега <a></a>) необходимо установить дополнительный
пакет (модуль). Для этого необходимо в консоль написать команду "npm i react-router-dom". Однако если просто прописать команду и выполнить её, модуль установится, но
после выгрузки проекта в репозиторий данные о наличии этого пакета не сохраняться, т.к. папка node_modules не прикрепляется к проекту выгружаемому на репозиторий. Чтобы
добавить запись о данном модуле и о том, что он используется в проекте необходимо в конце команды дописать "-save" (также нужно делать для всех остальный устанавливаемых 
вручную пакетов). Соответственно, полная команда выглядит так "npm i react-router-dom -save".

После ввода команды, в файл package.json добавится новая запись раздел "dependencies" (зависимости): "react-router-dom": "^6.22.3". Теперь мы можем пользоваться данным 
пакетом. Для этого, в месте где будет происходить изменение компонентов (в нашем случае в компоненте App.js), нам необходимо импортировать компоненты Route и Routes из 
"react-router-dom". Вызвать компонент <Route /> для каждого из возможных вариантов компонентов, которые мы хотим отображать в зависимости от URL адреса по которому обращаемся,
предварительно выделив область для перечня возможных к отображению компонентов с помощью <Routes> </Routes>. 
Т.е.
1. import { Routes, Route } from "react-router-dom";
2. Создать область с помощью 
    <Routes> 
        ...тут перечислять <Route /> для каждого компонента которые мы хотим вызывать 
    </Routes>
3. Для всех компонентов которые могут отображаться в определенной области задать <Route element={название_компонента}/>
Однако если запустить код браузер выдаст ошибку "Cannot read properties of undefined (reading 'pathname')"
Ввиду того, что на данном этапе компонент <Route /> знает какие ей необходимо вызывать компоненты, но не знает при каком URL страницы это нужно делать. Компонент видит URL
и думает по умолчанию, что при любом URL нужно отображать соответствующий компонент (а значит в данном случае отобразятся все компоненты). Делает он это из-за отсутствия 
свойства (атрибута) "path". Значит компоненту <Route /> необходимо задать еще один атрибут под названием path равный тому относительному пути который мы задали ссылкам 
ведущим (отображающим) к соответствующему компоненту.

Однако даже после этого ничего не заработает, т.к. зона маршрутизации (весь компонент в котором она происходит) должен быть обернут в другой компонент под названием 
<BrowserRouter>, который тоже импортируется из пакета "react-router-dom". 
Т.е. конечная запись импорта выглядит так: 
import { Routes, Route, BrowserRouter } from "react-router-dom";

А конечный синтаксис для создания маршрутизации так: 

<BrowserRouter>
    <Routes>
        <Route />
        <Route />
        <Route />
        ... (количество возможных для вызова компонентов)
    </Routes>
</BrowserRouter>

// 20 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данном этапе настроенная маршрутизация с помощью ссылок (тегов <a></a>) перезагружает страницу полностью при каждом изменении URL. SPA так работать не должно. Оно должно
просто отрисовывать компонент из JS загруженного кода, но не перезагружать каждый раз страницу, т.к. та самая оптимизация SPA при таком подходе не работает и ReactJS 
применяется бессмысленно. Чтобы исправить такое поведение, нам нужно вместо тега <a></a> использоваться тег <NavLink></NavLink> и вместо атрибута href="" использовать
атрибут to="", значение которого также остается равным дописи к URL адресу (относительному корневой папки проекта пути без точек).
Собственно данный компонент <NavLink></NavLink> служит для того, чтобы задать певедение ссылке (тегу <a></a>) с исключением - он отменяет перезагрузку (preventDefault) 
ссылки. Т.к. <NavLink></NavLink> является компонентом его нужно импортировать как пакет из модуля "react-router-dom". Чтобы импортировать именно определенный пакет по
его названию (или несколько пакетов) нам необходимо заключить его имя в строке импорта в фигурные скобки как мы это делали ранее при импорте {BrowserRouter, Route, Routes}
Строка импорта: import { NavLink } from "react-router-dom";

NavLink под капотом задает последней кликнутой ссылке класс "active" (внутри HTML) для того чтобы мы могли определенным образом помечать текущую ссылку, например, другим
цветом. Важно, что добавленный с помощью NavLink класс "active" и заданный нами в CSS модуле класс "active" не будут равны, т.к. CSS модуль добавляет префиксы и постфиксы
для идентификации CSS стилей к каждому компоненту и избежания пересечения имён классов. Соответственно, NavLink в любой случае будет задавать простой класс "active" и он
не может знать какие префиксы и постфиксы будут у того "active" который мы раскрашиваем. Чтобы дать ему понять, что нужно добавлять не просто "active", а тот "active"
который лежит в объекте возвращаемом CSS модулем по ключу "active" нам необходимо задать следующий класс: 
className={ navData => navData.isActive ? NavigationStyles.active : NavigationStyles.link}

Что тут происходит?
1. NavLink возвращает определенные данные (navData) которые содержат всю информацию о данном атрибуте (активен или нет, какие URL и т.д.)
2. В фигурных скобках мы обрабатываем эти данные и в зависимости от значение поля isActive (true или false) реализуем ту или иную часть условного выражения (конструкция ? :)
3. По результатам этого условного выражения для простой (не активной) возвращаем класс для обычной ссылки, для активной ссылки возвращаем класс "active" из фигурных скобок
4. Данный класс вызывается из CSS модуля, а значит имеет необходимые постфиксы и префиксы и соответственно присваивается атрибуту className

Тем самым мы "говорим" NavLink'у "Дружище, не мог бы ты добавлять активным ссылкам не просто класс active, как ты это делаешь по умолчанию, а вот этот класс - 
NavigationStyles["active"]".

Ссылкам добавленным внутрь <li></li> необходимо задать display: block; чтобы они отображались относительно родительского <li></li>

Для самостоятельного изучения вне курса - "history API HTML5"

// 22 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для того чтобы на странице диалогов отображались чаты (список сообщений) в зависимости от выбранного пользователя, нам также как и раньеш необходимо использовать в качестве
элементов списка пользователей не простые ссылки, а <NavLink></NavLink>. Задавая им атрибут to="/2", возникает логичный вопрос: "Если по этому URL мы открываем конкретный чат,
а Route для компонента Dialogs ждет от нас именно путь "/dialogs", то при изменении URL на "/dialogs/2" не пропадет ли компонент Dialogs со страницы?"
Ответ: нет, т.к. URL адрес читается слева направо и отображается компоненты последовательно, т.е. в адресе "http://localhost:3000/dialogs/2" браузер понимает, что сначала
нужно отобразить Dialogs, а затем внутри него ещё какой-то компонент по относительному пути в уже отображенном Dialogs, т.к. маршрутизация осуществляется уже внутри него. 

Соответственно, все чаты (список пользователей с которым есть переписка) нужно обернуть следующим образов в тег <NavLink></NavLink>:
<NavLink to="/1" className={navData => navData.isActive ? DialogsStyles.activeChat : DialogsStyles.chat}>
    <p className={DialogsStyles["user_name"]}>Лиза</p>
</NavLink>

Для того чтобы нижеприведенная запись отображала компонент ТОЛЬКО в случае если путь равне данному, то необходимо ещё добавить атрибут exact.
<BrowserRouter>
    <Routes>
        <Route exact path="/dialogs" element={названиеКомпонента} />
    </Routes>
</BrowserRouter>

Теперь данный Route не будет отображать компонент Dialogs при URL "/dialogs/2" в поисковой строке.

Однако в данном случае для изменения содержания блока "messages_with_user" (правой части компонента Dialogs), получается нам для каждого пользователя нужно загружать новый 
компонент? Для пользователя Лиза ждать путь "/dialogs/1" и далее добавлять соответствующий <Route /> и так для каждого вручную? 
Ответ: нет, можно использовать один компонент с разным наполнением (контентом) в зависимости от URL, но прежде чем понять как это работает нужно вспомнить props

* Заметка не по теме
Конструкция ниже просто добавляет слушатель события изменения URL адреса в определенном месте, но никак не связана с навигационной панелью и ссылками

<BrowserRouter>
    <Routes>
        <Route exact path="/dialogs" element={названиеКомпонента} />
    </Routes>
</BrowserRouter>

Сами <NavLink></NavLink> изменяет URL и отображают ссылку выделенной, но тоже никак не связаны с уровнями приложения и конструкцией выше
Грубо говоря, если <BrowserRouter> => <Routes> => <Route /> находится в Idea (внутри Ideas, внутри IdeaZone и т.д.), а сама ссылка задающая путь для этой Route в header 
страницы, то всё будет работать. Двум этим конструкциям необязательно находится на одном уровне или в одном компоненте.
*

// 23 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке, создадим гибкую компоненту для чатов (из списка пользователей с которыми есть сообщения) с помощью props и также создадим гибкую компоненту для 
отображения сообщений (упростим/отрефакторим код)

// 24 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
BLL - business logic layer (инкапсулирует всю бизнес-логику, все необходимые вычисления, получает объекты из уровня доступа к данным и передает их на уровень 
представления, либо, наоборот, получает данные с уровня представления и передает их на уровень данных)

UI - user interface (отображает полученные данные, благодаря BLL и отрисовывает их, либо передает какие-то данные (или команды) уровню BLL)

Концепция UI - BLL предполагает постоянное разделение двух этих уровней, поэтому данные пользователей хранить в качестве атрибутов для компонентов не совсем правильно
и логично, а значит их нужно выносить в отдельные "хранилища" памяти, а обрабатывать уже с помощью шаблонных компонентов ReactJS (через props)

Поэтому зададим массив пользователей и отобразим их пока что тоже в ручную без использования методов массивов
let usersForChats = [
    { id: 1, name: "Лиза", age: 23 },
    { id: 2, name: "Юля", age: 46 },
    { id: 3, name: "Андрей", age: 49 },
    { id: 4, name: "Никита", age: 22 },
    { id: 5, name: "Борис", age: 69 },
    { id: 6, name: "Наталья", age: 67 },
]
И отобразим таким образом: 
<DialogItem name={usersForChats[0].name} id={usersForChats[0].id} />

Ту же процедуру необходимо проделать с сообщениями и постами (т.е. со всеми сущностями нашего проекта)
Микро-спойлер:
BLL = Redux
UI - ReactJS

На данном этапе существует одна проблема: мы не знаем какого размера массив данных у нас будет, и поэтому ручное создание компонентов отображающих сущности неэффективно,
поэтому нужно использовать методы перебора массивов (объектов и т.д.), этому и будет посвящен следующий урок

// 25 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для динамического отображения данных в компоненте используем метод массивов map()
Создадим логику отображения компонента с данными сущности для каждой сущности массива данных, для постов (идей), сообщений и пользователей (чатов)

// 26 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Вынесем в отдельные компоненты <Message /> и <DialogItem /> из <Dialogs />.

UI (в нашем случае ReactJS) - набор файлов, который отвечает за отрисовку данных, которые приходят не из сервера напрямую, а из дополнительной прослойки (мы не отправляем
запрос на получение данных в файлах User Interface - мы делаем это в файлах BLL)
BLL - набор файлов, функций и т.д. отвечающий за хранение данных (в связке с ReactJS в роли BLL выступает Redux)

Ввиду этой концепции (Single resposibility) данные должны находится отдельно от компонентов (в других файлах). Т.е. следующие массивы данных в <Dialogs /> должны быть вынесены:
let usersForChats = [
    { id: 1, name: "Лиза", age: 23 },
    { id: 2, name: "Юля", age: 46 },
    { id: 3, name: "Андрей", age: 49 },
    { id: 4, name: "Никита", age: 22 },
    { id: 5, name: "Борис", age: 69 },
    { id: 6, name: "Наталья", age: 67 },
]
let messagesData = [
    { id: 1, text: "How are you?" },
    { id: 2, text: "Let's go to learn ReactJS" },
    { id: 3, text: "Are you sure about this?" },
    { id: 4, text: "Not exactly" },
    { id: 5, text: "So let's go to the park" },
]
И данные из Ideas тоже:
let postIdeaData = [
    { id: 1, likesCount: 7, text: "I'm pooping" },
    { id: 1, likesCount: 21, text: "Why don't we create an app" },
    { id: 1, likesCount: 14, text: "How to create a react app?" },
    { id: 1, likesCount: 52, text: "This's terribly difficult" },
]

Ввиду того, что в нашем проекте все файлы кроме index.js являются компонентами, а index.js выступает в роле руководителя (менеджера), то данные из всех компонентов логично
вынести в него и оттуда передать по компонентам. Т.е. в нашем случае BLL будет представлен index.js (изображение с структурой проекта прикреплено в папке урока)

*
Для самостоятельного изучения вне курса "Принципы SOLID"
*

// 27 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для того чтобы прокинуть props в компонент который отображается с помощью <Route path="/dialogs" element={<ComponentName />} />, достаточно просто передать данные props в 
компонент отображающийся благодаря этому <Route />, т.е. element={<ComponentName messageText={props.text}/>}. Всё достаточно логично, однако ввиду того что вместо атрибута
element раньше использовался component={<ComponentName />}, и такой подход был недоступен. Раньше использовали вместо component атрибут render, принимающий анонимную функцию,
которая в свою очередь возвращала компонент (а значит появилась возможность передать в этот компонент props), т.к. он не напрямую находится в Route. Теперь же с обновлением
"react-router-dom" версии 6 component и render как бы объединили в одно атрибут element (свойство)

// 28 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данном этапе, у нас в файле index.js содержаться и данные и отображение UI, что противоречит концепции Single Resposibility, а значит данные необходимо переместить в 
другой файл. Для этого создадим папку Redux на одном уровне с Components и поместим в нее наш файл с данными, обернутыми в объект под названием state, где свойства 
объекта - это названия массивов данных, а значения - сами массивы. Данные оборачиваем в объект для того чтобы экспортировать из файла с данными только лишь один объект, 
а не все переменные которые мы бы имели с соответствующими массивами (грубо говоря оборачиваем всю кучу в мешок)
После импортирования файла state.js (который экспортирует сам объект обертку), его необходимо передать в компонент App.js через props. В данном случае, мы не делим данные
как делали это раньше, а передаем общий объект со всеми данными. После данного шага, при дальнейшей транспортировки данных необходимо надпись props.messages заменить на 
props.state.messages (state - это название объекта props который мы передаем в App.js). 
На данный момент концепция Redux как раз такая, какая сейчас у нас, т.е. все данные проекта хранятся в одном файле state.js и из него уже передаются в UI. И в ситуациях
когда мы имеем большой проект и огромное количество данных, нам не хочется иметь их все на одном уровне вложенности без какой-либо группировки. Для того чтобы избежать
беспорядка в данных мы можем их структурировать, объединяя блоки данных в объекты внутри объекта state (группируя), с условием того, что эти блоки будут иметь аналогичное 
название (или соотвествующее) с компонентами в которых они используются. Т.е. в объекте state создаем два новых объекта profilePage и dialogsPage в которые и помещаем данные
которыем используются соответственно в <Profile /> и <Dialogs />. Важно отметить, что мы создаем нвоые объекты для группировки как свойства глобального объекта state (а их
значения - это объект содержащий в себе в качестве свойств названия массиво и в качесвте значений сами массивы).
Т.е.
let state = {
    // Данные для Dialogs
    dialogsPage: {
        usersForChats: [
            { id: 1, name: "Лиза", age: 23 },
            { id: 2, name: "Юля", age: 46 },
            { id: 3, name: "Андрей", age: 49 },
            { id: 4, name: "Никита", age: 22 },
            { id: 5, name: "Борис", age: 69 },
            { id: 6, name: "Наталья", age: 67 },
        ],
        messagesData: [
            { id: 1, text: "How are you?" },
            { id: 2, text: "Let's go to learn ReactJS" },
            { id: 3, text: "Are you sure about this?" },
            { id: 4, text: "Not exactly" },
            { id: 5, text: "So let's go to the park" },
        ],
    },

    // Данные для Profile -> Ideas
    profilePage: {
        postIdeaData: [
            { id: 1, likesCount: 7, text: "I'm pooping" },
            { id: 1, likesCount: 21, text: "Why don't we create an app" },
            { id: 1, likesCount: 14, text: "How to create a react app?" },
            { id: 1, likesCount: 52, text: "This's terribly difficult" },
        ],
    }
}

Подобъекты - являются ветками, обслуживающими отдельные страницы.
Теперь остается зарефакторить использование этих данных при передачи их в компоненты с помощью props.

Мы должны использовать чистые функции (компоненты), а это значит, что мы недолжны передавать в компонент (функцию) любые данные с которыми данная функция не работает.
Также можно передавать в дочерние компоненты локальные props с названием state. Например, в Route внутри App.js:
<Route
    path="/profile" element={<Profile state={props.state.profilePage} />}
/>
для того, чтобы в самом Profile вызывать не props.postIdeaData, а props.state.postIdeaData
Это удобно, т.к. если в рамках одного Route нам нужно передать дважды (или более) данные для его дочерних компонентов, то мы просто передаем ему все данные которые 
используются в рамках этого компонента, а уже внутри него их сортируем. 
Т.е. вместо 
<Route path="/dialogs" element={<Dialogs messagesData={props.state.dialogsPage.messagesData} usersForChats={props.state.dialogsPage.usersForChats}/>}
мы просто передаем сам объект обертку для компонента <Dialogs />
<Route path="/dialogs" element={<Dialogs state={props.state.dialogsPage}/>} 
и уже внутри самого компонента разбиваем полученный локальный state на:
{props.state.messagesData} и {props.state.usersForChats}

*
Заметка не по теме:
Для того чтобы наладить routing в нашем проекте, нам не нужно оборачивать каждый навигационный блок в компонент <BrowserRouter></BrowserRouter>, а достаточно обернуть 
все содержимое сайта в файле index.js. При это необходимость оборачивать блоки навигации в <Routes></Routes> остается.

✅ Домашнее задание: добавить раздел друзей в sidebar и добавить аватарки для сообщений в чатах

// 31 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке мы начнем работать с динамикой, а именно, с изменением данных в нашем state.js благодаря определенным действиям произведенным в UI, а также научимся 
отлавливать данные действия пользователя и связывать их с данными (BLL). Основной ход событий идёт в файле Ideas.jsx 
Для того чтобы задать слушатель события какому-либо элементу в JSX необходимо в качестве атрибута задать onНазваниеСобытия={функция, выполоняющаяся при выполнении события}.
Т.е. синтаксис такой: <button onClick={ () => alert("Вы кликнули") }>Кликай тут</button>

Значением данного атрибута всегда должна быть callback функция (функция, которую мы передаем чтобы ее кто-то вызвал, а не вызываем сами). Внутри данной callback функции 
может находится большое количество строк кода и для того чтобы не раздувать разметку и делать код менее читаемым, функцию которую мы передаем в качестве значения аргумента
слушателя события лучше задать не внутри JSX, а просто внутри самого компонента. Обозначит функцию и после вызвать её.

Внутри функции, которая будет вызываться при реализации события, нам нельзя использовать document.getElementById и подобные конструции, т.к. данные конструкции взаимодействуют
напрямую с DOM-деревом, а ReactJS устроен таким образом, что сам забирает на себя вопросы взаимодействия с DOM-деревом и оптмизированно это всё делает. Для этого в React'е 
реализована концепция VirtualDOM.

Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется 
с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.
Соответственно мы не имеем право вмешиваться в работу ReactJS, что и означает, что использовать конструкции работающие с DOM деревом напрямую, нельзя.
(Одна из причин такого поведения заключается в том, что мы не знаем в конкретный момент времени отрисовано ли DOM-дерево на странице, т.е. мы взаимодействуем с каким-то 
элементом, но при это не уверены, находится ли он в момент взаимодействия в DOM-дереве, поэтому лучше взаимодейтсвовать с VDOM чтобы исключить наличие ошибок. А сам VDOM за
нас после полноценной своей загрузки отображает данные в DOM-дерево и только после этого выполняет функционал (грубо говоря подготовительный этап с целью уменьшить риски))

Соответственно для того чтобы получить элемент из VDOM-дерева нам необходимо использовать какой-то синтаксис вместо document.querrySelector() и др. 
Для того чтобы получить элемент из JSX кода нам необходимо:
1. Создать переменную в которую будет помещена ссылка на конкретный элемент VDOM
let newPostTextarea =
2. Для того чтобы показать React'у что тут будет храниться ссылка на элемент VDOM значение этой переменной должно быть равно вызову метода CreateRef() у модуля React
let newPostTextarea = React.CreateRef()
3. Сам элемент привязать к данной ссылке с помощью создания у него атрибута ref={названиеПеременной} (в которой лежит пустая ссылка)
let newPostTextarea = React.createRef()
<textarea ref={newPostTextarea}></textarea>

Важно, что для того чтобы использовать методы модуля React его необходимо импортировать с помощью 
import React from "react";

Каждая ссылка, созданная с помощью let newPostTextarea = React.CreateRef() - является объектом, всего с одним свойством current, которое в свою очередь ссылается на 
нативный HTML элемент (судя по всему уже непосредственно на DOM элемент, но это нужно уточнить *уточнил, всё правильно - напрямую к элементу DOM дерева*), поэтому для 
того чтобы получить значение данной textarea нам нужно использовать следующий синтаксис:

let textFromTextarea = newPostTextarea.current.value
    Где:
    newPostTextarea = {current: someNodeFromDOM}
    newPostTextarea.current = someNodeFromDOM
    newPostTextarea.current.value = текстовое значение этого элементам

Но при таком подходе важно понимать что взаимодействие (изменение элемента) происходит напрямую в DOM, а не в VDOM и поэтому данный вопрос ещё будет объясняться в следующих
уроках.
Соответственно, теперь нам необходимо полученные изменения (как в нашем примере, созданный новый пост) поместить в state.js и поновой отрендерить весь проект с целью 
повторного прокидования props внутри UI части, т.к. просто поместить данные в state.js - не значит отобразить их сразу же (т.к. помещение данных в другой файл не перерисовывает
компоненты заново). Как это сделать - тема следующего урока.

✅ Домашнее задание: добавить в компоненте Dialogs <textarea></textarea> и реализовать всю ту же логику сохранения напечатанного текста. (Сделано в CreateMessage.jsx)

// 32 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данном этапе мы научились отслеживать и получать данные не обращаюсь напрямую к DOM дереву через document. и т.д., а значит теперь нам необходимо передать внесенные 
изменения в бизнес логику проекта, т.е. в BLL. Для этого необходимо при добавлении сообщения или профиля, например, изменять и дополнять данные в state.js
Ввиду того, что функция, изменяющая данные должна быть в одном файле с данными (в state.js) нам необходимо её реализовать соответственно в этом же файле.
Для того чтобы вызвать функцию из state.js (верхний уровень - BLL) нам нужно прокинуть её с помощью props в необходимый компонент (для этого нужно экспортировать её из
state.js НЕ по дефолту). Поэтому идём в state.js и создаем эту функцию (addPostIdea):

let addPostIdea = (textOfIdea) => {
    let newPostIdea = {
        id: 5,
        likesCount: 0,
        text: textOfIdea,
    }

    state.profilePage.postIdeaData.push(newPostIdea)
}

Для того чтобы созданную функцию экспортировать не по дефолту, в момент создания функции пишем "export let названиеФункции = и т.д.". Теперь, для того чтобы её импортировать,
нам необходимо заключить в фигурные скобки имя данной функции, чтобы было понятно, что именно мы ищем в данном файле (без фигурных скобок будет импортировано то, что 
экспортируется по дефолту). При данном подходе мы в файле ищем именно то название которое есть в экспортирующем файле, а не как в случае без фигурных скобок, просто задаем
собственной название для элемента, который экспортируется по дефолту. Чтобы импортировать данную функцию в index.js напишем там 
import {addPostIdea} from './redux/state'

Теперь по аналогии с state необходимо прокинуть данную функцию по цепочке в компонент <Ideas /> и вызвать в нужном месте (в функции для слушателя событий). Т.е. при реализации
события будет вызвана функция из state.js, которая работает с данными в данном файле. 
Однако стоит отметить что при реализации события несмотря на то что функция вызывается визуального сопровождения нет (пост не добавляется на стену), т.к. компоненты не 
рендерятся по новой, т.к. функция всего лишь добавляет элемент в массив постов, но не заставляет React перерисовать UI 
Важно понимать, что функция находящаяся в другом файле и вызывающаяся из определенного места в компоненте с переданными параметрами на самом деле все равно вызывается в том
файле в котором была инициализирована, однако такой подход позволяет передать параметры для этой функции, как в нашем случае, из UI в BLL уровень
Отсюда делаем вывод, что каждый раз при изменении BLL уровня UI должен перерисовываться (несмотря на то, что может казаться, что это неэффективно)
*Насколько я помню React использует алгоритм поиска отличий, а значит "под капотом" данный процесс все равно как-то да оптимизирован*
Как по новой перерисовать компонент (и немного концепции FLUX) станет известно в следующем уроке.

// 33 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для того чтобы перерисовать (выполнить рендер) всё UI-приложение нам необходимо вызвать функционал index.js, а именно:
root.render(
    <BrowserRouter>
        <App state={state} addPostIdea={addPostIdea} />
    </BrowserRouter>
);
в определенный момент времени, когда мы изменяем данные в state.js
Обернуть данный функционал в функцию, выполнить её один раз для первоначального render'а и экспортировать её в state.js с целью последующего её вызова внутри функции 
addPostIdea() при изменении данных в state.js. 
Т.е. при срабатывании события, считанная из textarea строка, благодаря функции обработчика событий, записывается и попадает в addPostIdea(таСамаяСтрока) в качестве параметра, 
а затем по цепочке вверх данный параметр передается до момент инициализации функции addPostIdea() в файл state.js и вызывается там изменяя массив данных, а после 
перерисовывает всё приложения, опираясь на новые данные.

let renderEntireTree = () => {
    root.render(
    <BrowserRouter>
        <App state={state} addPostIdea={addPostIdea} />
    </BrowserRouter>
    );
}
renderEntireTree()

Однако у данного подхода есть существенный минус и поэтому так делать нельзя. При таком подходе создается циклическая зависимость, т.к. до этого из state.js мы экспортируем 
данные в index.js, а теперь наоборот пытаемся из index.js экспоритровать в state.js функцию renderEntireTree(). Для более наглядного понимания, схемы приложения приложены в 
папку проекта.

Чтобы избежать пересечения импортов и циклической зависимости нам необходимо добавить третьего игрока - render.js в наш проект, который и будет содержать в себе функцию 
renderEntireTree(). Соответственно, функционал index.js переносится практически полностью в render.js
render.js выполняет функционал создания функции рендера и экспортирует эту функцию (важно, что render.js не создает корень). 

Эту функцию нам нужно использовать дважды:
1. Внутри index.js для начального рендера компонентов
2. Внутри state.js для ререндера приложения при изменении бизнес логики функцией addPostIdea() или аналогичными

Соответственно экспортировав renderEntireTree в эти два места всё равно ничего работать не будет, т.к. теперь есть циклическая зависимость между 
render.js передает renderEntireTree() ---> state.js
state.js передает state ---> render.js 
(на самом деле всё будет работать, но быть не должно и это всё - говнокод)

Соответственно, удалить renderEntireTree() из файла state.js мы не можем, т.к. после этого не получится перерисовывать данные, а значит мы должны удалить наоборот state из 
render.js. Но теперь мы не передаем данные никуда и при этом файлу render.js нужен state чтобы перерисовать его и отобразить опираясь на данные!

💡Гениальное решение:
Функция работает с параметрами, а значит ввиду того, что в render.js мы не вызываем функцию renderEntireTree() нам необязательно рабоать именно с state - объектом
Мы можем задать поведение для тех, кто будет вызывать данную функцию renderEntireTree(), обработав при её инициализации работу с параметрами, и сказать, что если кто-то
вызывает эту функцию и передает в нее параметр, то это должен быть (мы ожидаем) объект state и соответственно теперь мы можем передать в index.js который никому ничего не 
экспортирует (имеется ввиду render.js и state.js) данные из этих файлов и вызвать функцию renderEntireTree() передав в нее в качестве параметра state - объект данных
В данном случае index.js выполняет собирающую функцию и реализует функцию renderEntireTree(state)

Значит при таком подходе функцию addPostIdea() тоже нужно вынести в index.js чтобы избежать пересечения
render.js передает renderEntireTree() ---> state.js
state.js передает addPostIdea() ---> render.js 

Для этого добавим ещё один параметр функции renderEntireTree()

Что мы сделали чтобы избежать циклических зависимостей более подробно:
1. Выделили функцию рендера в отдельный файл render.js 
2. Написали для этой функции как обрабатывать входящие параметры (чтобы не импортировать в render.js объект state, т.к. мы уже вынуждены импортировать функцию renderEntireTree
внутрь state.js (чтобы вызывать ее когда нужно ререндерить приложение после изменения данных от VIEW))
3. Файл index.js стал "собирательным" т.к. из него мы ничего не экспортируем, а просто единожды вызываем импортированную renderEntireTree() (в момент первоначальной 
загрузки страницы выполняется index.js единожды (в этом и заключается коцепция SPA, т.к. больше ничего мы не подгружаем)) и передаем в неё в качестве параметров объект 
state и функции изменения этого объекта.
Таким образом у нас получается некое подобие концепции FLUX (сриншот приложен в папку проекта)

В нашем случае:
action (сторонний не от VIEW) - первоначальная загрузка страницы
store - хранилище данных = state.js
dispatcher - функция, меняющая состояние хранилища (state.js) = addPostIdea()
action (от VIEW) - клик по кнопке "Добавить пост"

Полезная ссылка по FLUX + useReducer: https://www.youtube.com/watch?app=desktop&v=UQTT9IDctys&ab_channel=%D0%9F%D0%BE%D0%BB%D0%B8%D0%BD%D0%B0%D0%BF%D1%80%D0%BEFrontend%F0%9F%92%9C

Чтобы обнулить текст textarea для создания поста после публикации поста (идеи) нам необходимо

Важно понимать, что для того чтобы приложение работало не только в визульном формате, первоначальное действие при реализации события - это изменить данные в Redux, а отрисовать 
по новой UI-часть уже нужно на основе измененных данных (это реализуется функцией ререндера внутри функции изменяющей данные ( renderEntireTree() ))

FLUX - это концепция, а Redux - конкретная реализация этой концепции

// 34 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данной концепции UI должен меняться в ответ на изменение state и соответственно, когда мы пишем что-то, например, в textarea мы изменяем UI (т.к. совершаем action, 
однако на данном этапе он не вызывает ререндер, но тем не менее какое-то действие мы совершаем и изменяем UI т.к. теперь у нас есть какой-то текст в textarea). При этом
сам state никак не меняется, а следовательно, такое поведение противоречит концепциям FLUX, Single Resposibility и т.д. потому что компонента созданная для простой 
отрисовки занимается изменением UI, что по идее должно происходить только с помощью ререндера приложения во время изменения state
Соответственно, для того чтобы соблюдать концепцию при вводе в textarea какого-либо текста, изначально нужно не отрисовать на UI изменение, а произвести изменения значения 
в state (с помощью обработчика событий onChange и функции изменения необходимой части в state, отображающейся по умолчанию в textarea, т.е. newPostIdeaText: ""). 
При изменении state как мы знаем происходит ререндер, а значит нам приходят новые данные в UI и приложение ререндерится, а следовательно, перерисовывается. 
По итогу получается такой своего рода посимвольный ререндер приложения (но нужно отметить, что в реальности, благодаря тому что React использует алгоритм сравнения 
изменений полный ререндер не производится (под капотом React сравнивает предыдущее состояние и добавляет только изменения, при этом весь проект хоть и ререндерится 
номинально, благодаря нашей функции renderEntireTree(), которую мы вызываем на соответствующее поле в state (в данном случае newPostIdeaText), тем не менее полноценной 
перерисовки всего приложения не происходит из-за оптимизации React))

Для того чтобы реализовать данный подход нам необходимо создать в state.profilePage новое свойство newPostIdeaText с значением пустой строки и повесить на сам тег 
обработчик событий, который будет на каждое изменение текста в textarea, сначала вызывать функцию изменения newPostIdeaText внутри state, а та в свою очередь 
будет ререндерить UI и отрисовывать изменения (посимвольная отрисовка).

Теперь нужно:
1. Создать обработчик события onChange
2. Создать функцию изменения состояния свойства newPostIdeaText внутри state.js, принимающую в качестве параметра новый текст введенный в textarea и ререндерющую приложение
после изменение самого состояния newPostIdeaText
3. При реализации события обработчик должен вызывать функцию, которая считывает изменения в textarea с помощью React.createRef() + ref={}, и вызывает функцию изменения,
созданную в п.2 (предварительно импортированную по всей цепочки от state.js)
4. Важно, что теперь функция ререндера - renderEntireTree() должна уметь обрабатывать третий параметр т.е. передавать в <App /> помимо state (с набором данных для отрисовки),
addPostIdea() (добавляющую пост при клике на кнопку (обработчик вызывает ее при клике)) ещё и функцию updateNewPostIdea()
5. И соответственно все вызовы renderEntireTree() должны иметь 3 параметра (т.к. например если вызов addPostIdea() будет иметь только 2 предыдущих параметра которые были
нужны до реализации FLUX концепции (посимвольно), то при добавлении поста addPostIdea() вызовет renderEntireTree(state, addPostIdea) и соответственно функция 
updateNewPostIdea будет равна undefined из-за перерисовки вызванной этой renderEntireTree()) 

Теперь чтобы обнулить содержание textarea нам также необходимо взаимодействовать с UI через state, т.к. запись createPostTextarea.current.value = ""; теперь обнуляет текст
внутри textarea независимо от BLL, т.е. нарушает концепцию отрисовки UI только исходя из полученных из BLL данных. Теперь для того чтобы взаимодействоать с newPostIdeaText
внутри state для обнуления textarea достаточно после добавления поста вызваться функцию изменения состояния свойства newPostIdeaText, а именно - updateNewPostIdea() передав
в качестве параметра пустую строку

Для того чтобы всё работало надо не забыть добавить textarea атрибут value равный пришедшему из props свойству объекта state - newPostIdeaText. В противном случае при 
добавлении текса каждый символ будет приходить в state благодаря функции updateNewPostIdea(), но renderEntireTree() который она вызывает не будет перерисовывать содержание
textarea т.к. сама textarea независит никак от приходящих данных

На данном этапе нам нет необходимости вызывать функцию addPostIdea() и передавать в неё текст, полученный с textarea, т.к. актуальное содержимое этой textarea уже содержится 
в state в свойстве newPostIdeaText. Соответственно, теперь можно упрастить код и не считывать текст находящийся в textarea на момент нажатия кнопки "Post"

Соответственно, и обнуление содержимого textarea после добавления поста, мы можем теперь выполнить внутри state, после того как добавим объект с данными поста в массив объектов.
Это можно сделать внутри функции добавления поста просто перезаписав state.profilePage.newPostIdeaText = "";
*
При этом стоит отметить, что мы всё равно нарушаем концепцию функционального программирования т.к. обращаемся в функциях addPostIdea() и updateNewPostIdea() к глобальному 
объекту state (а по концепции функция должна работать лишь с тем, что приходит в неё).
*

✅ Домашнее задание: сделать ту же логику с созданием сообщений, что и с написанием поста

// 35 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
По какой-то непонятной на данный момент причине нужно обратно удалить файл render.js и перенести его логику в index.js. Соотвтественно опять возникает вопрос как получить в 
файле state.js функцию ререндера - renderEntireTree(), избежав циклической зависимости (т.к. мы в первую очередь вынуждены импортировать в index.js объект данных state и 
получается при экспорте из index.js функции renderEntireTree() мы не можем импортировать из state сами данные).

Ранее мы уже пользовались этим методом:
У нас должа была быть циклическая зависимость:
App.js ------<App />------> index.js (чтобы вызвать этот компонент в index.js)
index.js -------addPostIdea(),updateNewPostIdea(),addMessage(),updateNewMessage()------> App.js

Соответственно, чтобы избежать такой зависимости мы не импортируем из index.js функции, а внутри самого index.js при вызове компоненты App.js передаем в нее данные функции
с помощью props. По итогу циклической зависимости нет, а значит, ничего нам мешает применить тот же подход для цепочки:
state.js ------State-----> index.js
index.js ------renderEntireTree()------> state.js

Важно! На данном моменте рассматривается подход для передачи каких-либо данных вверх по цепи.

state.js (тут нужно получить функцию из index.js не импортируя её)
|
|
|
index.js

Т.е. для решения поставленной проблемы можно использовать следующий подход:
1. Создать внутри state.js пустую функцию renderEntireTree() (не та функция которая задана в index.js, т.к. она там и остается) с помощью let
2. Создать и экспортировать из state.js функцию subscribe(), принимающую в качестве параметра другую функцию (назовем параметр observer - наблюдатель) с функционалом
переопределения функции renderEntireTree() (пустой заглушки внутри state) на функцию которая передана в качестве параметра при вызове самой subscribe(observer), т.е.

export const subscribe = (observer) => {
    renderEntireTree = observer
}

3. На данном этапе мы экспортируем только из state.js вниз по цепи (из index.js ничего в state.js не экспортируется)
4. Экспортируем эту функцию также вниз по цепи от state.js к index.js

state.js
  |
  |
state
addPostIdea()
updateNewPostIdea()
addMessage()
updateNewMessage()

subscribe() - самый главный в данном уроке экспорт из state.js
  |
  |
  \/
index.js

5. Вызываем эту функцию внутри index.js и передаем в качестве параметра уже настоящую функцию renderEntireTree() (не заглушка, а нормальная функция рендера из index.js)
6. Теперь ввиду вызова этой функции с таким значением параметра, несмотря на то что функция вызвана в index.js ее выполнение происходит следующим образом:
    в index.js - sunbscribe(renderEntireTree)
    функция вызывается и присваивает лежащей внутри state renderEntireTree() (пустой) - значение, переданное через параметры, а именно нормальную функцию renderEntireTree()
    а значит внутри state renderEntireTree() (заглушка) переназначается на нормальную функцию и при этом мы не использовали импорты

Итог: мы избежали циклических импортов, но получили функцию внутри state.js

Еще раз:
Если нам нужен какой-либо объект (или функция) на верхних уровнях и мы не можем использовать импорты с целью избежать циклической зависимости:
1. На верхнем уровне, где нам нужена функция - создаем пустую функцию заглушку 
2. Создаем функцию subscribe(), принимающую в себя параметром другую функцию и переназначающую функцию заглушку на переданный параметр при вызове sunbscribe()
3. Передаем subscribe() по имеющейся цепочке вниз через props
4. Вызываем в нижнем уровне функцию subscribe и передаем в нее в качестве параметра ту функцию которую хотим получить наверху
5. subscribe(observer) имеет функционал изменения функции на верхнем уровне на observer, а значит хоть она и вызвана внизу, однако изменения совершает на верхнем уровне
6. Теперь после ее вызова внизу, наверху наша заглушка стала равно observer.

Весь данный функционал называется паттерн observer (на этом паттерне работают обработчики событий)

Для самостоятельного изучения: паттерн observer

Следующий важный шаг это объект store (ООП) (несмотря на то, что React и Redux - это фукнциональное программирование, мы все равно будем использовать элементы ООП)

// 36 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
До этого у нас был обычный (тупой) объект содержащитй только данные - state. Однако, несмотря на то, что React базируется не на объектно-ориентированном принципе 
программирования, а на функциональном подходе, тем не менее нам все равно иногда придется использовать "умные" объекты (объекты реализующие какой-то фунгкционал - обладающие
методами). В роли такого объекта может выступать:

let man = {
    name: "Egor",
    age: 23,
    sayName() {
        alert(this.name)
    }
}

У объекта также могут быть приватные свойства (начинающиеся с нижнего подчеркивания: _content) с которыми не стоит взаимодейтсвовать напрямую. Т.е., например, у нас есть 
следующий объект:

let page = {
    title: "Lalalalalala",
    _content: ``,

    setContent(value) {
        // Тут может быть другая логика
        this._content = value
    }

    getContent() {
        return this._content
    }
}

Почему иногда важно не взаимодействовать напрямую с свойством объекта? Потому что иногда простое присваивание page._content = '<div>Some text</div>'; просто переназначает
содержание, но часто бывают случаи, когда нам нужно реализовывать какую-то логику дополнительно при установлении контента как в нашем случае (например считать количество
изменений контента и что-то подобное). И в таком случае намного удобнее использовать page.setContent('<div>Some text</div>') ведь внутри данного метода мы можем реализовать
автоматически другую логику и ее не нужно писать при каждом изменении _content.

*
Догадка
Скорее всего это подводка к глобальному объекту store в котором функции обновления состояни (посимвольно) и добавления/удаления элементов из определенных массивов данных
буду интегрированы как set-еры, а значит сама структура хранения данных и работы с ними будет более структурирована. И не придется отдельно рядом с state создавать функции
изменяющие сам state, т.к. соответствующие функции будут лежать в одних и тех же объектах с теми данными с которыми они должны взаимодействовать. Соответственно, для 
обращения к данным внутри этого объекта будет использоваться ключевое слово this

Догадка подтвердилась, далее речь пойдет про store
* 

Теперь у нас есть store включающие следующие свойства и методы:

let store = {
    _subscriber() {
        console.log("No subscribers (observers)") // это заглушка
    },
    _state() {
        firstName: "alalalalalla",
        lastName: "ulululululul"
    }
    getState() {
        return this._state
    }
    subscribe(observer) {
        this._subscriber = observer
    }
    setFirstName(value) {
        this._state.firstName = value;
        this._subscriber()
    }
}

Тут мы уже видим логику похожу на то, что мы написали в прошлом уровке. Т.к. есть частные свойства (методы) с которыми пользователь не взаимодейтсвует на прямую, есть заглушка
_subscriber() которая после вызова subscribe(observer) становится равно той функции которую в нее передали при вызове в другом файле (а значит становится функцией из другого
файла, но при этом, не используя импорт)

Теперь и сами данные и логика их взаимодействия инкапсулируется внутри объекта store и взаимодействие с частными (приватными) свойствами осуществляется через get-еры и 
set-еры.
В дальнейших уроках мы будем изобретать свой store и развивать его, для того, чтобы понять, как работает ровно такой же store интегрированный в Redux.
Важно то, что при таком подходе нам не нужно постоянно экспортировать отдельные функции и увеличивать количество параметров у функции рендера страницы, т.к. мы можем передать
один лишь объект store и внутри него в нужный момент вызывать необходимые функции. 

// 37 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Изначально "упакуем" все данные и функции из файла state.js в новый объект store. Теперь нет необходимости экспортировать функции отдельно от данных и соответственно, нужно
отрефакторить часть кода, в том числе и внутри самого store, т.к. теперь для обращения к state нужно использовать this.
Теперь при прокидовании store._state через props возникает ошибка, т.к. нельзя напрямую обращаться к приватным свойствам объекта store, а значит нужно создать соответствующий
get-ер - getState(). Переименуем renderEntireTree() на _callSubscriber() (уведомить подпищика-пользователя (отрисовать UI)), с нижнем подчеркиванием, т.к. это тоже приватный
метод с которым нельзя взаимодейтсвовать напрямую.

Вылетает ошибка введу того, что когда при создании объекта сообщения или объекта нового поста мы обращаемся к this._state данная конструкция как бы говорит найди _state 
внутри этого нового объекта, а не глобального объекта store
Плюс ко всему методы которые мы перекидываем в props такие как addMessage(), addPostIdea() и другие могут вызываться в контексте других объектов (не store, а как в нашем
случае у props, например, в <Ideas /> метод addPostIdea() мы вызываем таким образом props.addPostIdea(), а значит ключевое слово this в данном случае равно не store, а 
props), а значит мы должны забиндить необходимый нам контекст.
Такое поведение обусловлено возможностью в JS вызывать методы одного объекта в контексте другого. Соответственно теперь при прокидовании методов через props нужно дописать
к выражению store.addPostIdea - .bind(store)
Важно отметить, что метод bind не вызывает метод, а просто возвращает идентичную функцию имеющую контекст объекта, который был передан в этот bind в качетсве параметра, 
т.е., как в нашем случае, возвращает функцию с закрепленным контекстом объекта store.

<App
    state={store.getState()}
    addPostIdea={store.addPostIdea.bind(store)}
    updateNewPostIdea={store.updateNewPostIdea.bind(store)}
    addMessage={store.addMessage.bind(store)}
    updateNewMessage={store.updateNewMessage.bind(store)}
/>