// 51 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

На данном этапе, нам необходимо избавиться от фиксированных (захардкоженых) пользователей, которых мы добавляем с помощью setUsers()
Для того, чтобы писать запросы на сервер, необходимо использовать библиотеку "axios", а следовательно, нам необходимо её установить с помощью команды "npm i axios --save"
и импортировать с помощью "import * as axios from "axios";" (запись "* as axios" означает, что мы хотим импортировать всё что имеет название axios внутри библиотке, как
"axios" в наш проект).
Непосредственно создание запросов мы реализуем внутри презентационной компоненты в блоке if(){}, который мы реализовали на прошлом уроке.

Любая серверная API (определенные endpoint'ы) имеют базовый URL-адрес, который не изменяется относительно типа выполняемого запроса (т.е. часть URL запроса всегда 
фиксирована и эта часть и называется "базовый URL")

Наш базовый URL: "https://social-network.samuraijs.com/api/1.0"

Если мы хотим обратиться за конкретными ресурсами (данными), то мы обращаемся к конкретному endpoint'у на сервер, например, users/. Таким образом, что получить данные с 
сервера мы знаем, что надо использовать GET-запрос к endpoint'у users/, предварительно в URL-адресе запроса указать базовый URL. Т.е. для того, чтобы создать запрос, нам
необходимо воспользоваться следующим синтаксисом:

axios.get("https://social-network.samuraijs.com/api/1.0/users")

Функция get("URL-адрес") содержит под капотом функционал выполнения запроса на сервер и оборачивания его в промис. Соответственно, результат вызова данной функции - промис
и для того, чтобы обработать содержащийся в этом промисе результат выполнения запроса, нам необходимо вызвать у данного промиса метод then(), который принимает в себя
в качестве параметра сам результат выполнения запроса (response).
Синтаксис:

axios.get("https://social-network.samuraijs.com/api/1.0/users").then( (response)=>{
    *обработка ответа сервера*
} )

Логично, что данный функционал мы должны поместить внутрь блока if(props.users.length === 0){...}, ввиду того, что первоначальную установку пользователей функцией 
setUsers() мы будем выполнять автоматически (без нажатия на кнопку "Show more")

По данному запросу мы получаем объект (response), который содержит в себе большое количество свойств, а именно:

config: {transitional: {…}, adapter: Array(2), transformRequest: Array(1), transformResponse: Array(1), timeout: 0, …}
data: {items: Array(10), totalCount: 26169, error: null}
headers: AxiosHeaders {cache-control: 'no-cache', content-length: '1260', content-type: 'application/json; charset=utf-8', expires: '-1', pragma: 'no-cache'}
request: XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …}
status: 200
statusText: ""

Это объект ответа сервера (впринципе данные характеризующие сам запрос) и для того, чтобы добраться до данных, сидящих внутри этого объекта, нам необходимо обратиться к 
полю "data" (данные с сервера, полученный по данному запросу с сервера)

data: {
    error: null,
    items: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}],
    totalCount: 26169,
}

Значит на данном моменте, необходимые объекты пользователей (для отображения на странице) находятся внутри response.data.items, а значит в методе then(), вызванном после
выполнения запроса, мы должны обработать ответ сервера и получить эти данные, а затем передать их в функцию setUsers(), т.е.:

if (props.users.length === 0) {
    axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
        let users = response.data.items
        props.setUsers(users)
    })
}

Однако на данном моменте мы получим ошибку, ввиду того, что обрабатываем внутри презентационной компоненты свойства объекта пользователя, которых на самом деле у этих
объектов нет, например, "lcountry", "city" и др. Так происходит ввиду того, что полученный с сервера объекты имеют следующие поля:

{
    name: "Matuxa",
    id: 31161,
    uniqueUrlName: null,
    photos: {
        small: null,
        large: null
    },
    status: null,
    followed: false
}

А обработнные ранее объекты презентационной компоненты имели следующие:

{ 
    id: "1", 
    avatarURL: "https//worldpodium.ru/sites/default/files/styles/400x400sc/public/gosha_rubchinskiy.jpg?itok=q5UPHzac", 
    firstName: "Gosha", 
    secondName: "Rubchinskiy", 
    status: "I'm a big lover of potatoes", followed: true, 
    location: { 
        country: "Russia", 
        city: "Moscow" 
    }
}

Чтобы таких казусов не возникало на реалиных проектах, необходимо разрабатывать презентационные компоненты исходя из того формата данных, который разработан на сервере.
Т.е. изначально, нужно смотреть на то, какие объекты пользователя лежат на сервере и какие поля оин имеют, чтобы не создавать лишние ошибки и дополнительную работу себе
или бэкендеру. Исходя из этого, нам необходимо переписать функционал презентационной компоненты под текущие данные с сервера.

Для обработки аватарки пользователя, мы можем использовать функционал тернанрных выражений, чтобы в случае если у объекта пользователя нет собственной установленной 
фотографии мы возвращали фиксированную (серую) заглушку. Для этого, эту заглушку нужно добавить в папку проекта и импортировать внутрь презентационной компоненты. 
Соответственно, синтаксис будет следующим:

import BaseUserAvatar from "../../images/user_without_photo.jpg";
...
<img src={user.photos.small !== null ? (user.photos.small) : BaseUserAvatar} alt="Avatar" />

ВАЖНО:
В прошлом уроке мы допустили серьезную погрешность, т.к. выполняем запрос внутри презентационной компоненты, нарушая тем самым принцип чистых функций. Теперь при каждом
ререндере компоненты мы должны выполнять запрос на сервер (хоть мы и избежали этого поведения с помощью блока if(){...}, всё равно факт наличия дополнительного 
функционала непредусмотренного презентационной компонентой остается). Для того чтобы решить данную проблему, мы будем использовать классовые компоненты. Важно отметить, 
что сейчас данный вопрос решается с помощью хуков, но мы будем все равно использовать устаревшие классовые компоненты и постепенно придем к хукам (т.к. понимание хуков
строится на понимании классовых компонентов).

// 52 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

Чтобы функция оставалась чистой, мы не должны, как в уроке ранее, допускать выполнение каких-либо "Side Effects", т.е., например, запросов на сервер, модификаций входящих
данных (т.к. функция работает только в пределах своей области ответственности и не может изменять хранящиеся в другом месте данные), изменения DOM дерева и др (скриншот
приложен в папку проекта).
Исходя из выше сказанного, в нашем проекте презентационная компонента <Users /> на данном этапе выполняет следующий Side Effect:

if (props.users.length === 0) {
    axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
        let users = response.data.items
        props.setUsers(users)
    })
}

Исходя из того, что у нас нет гарантий того, что данные на сервере не изменятся, мы не можем утрверждать что данный функционал всегда вернет предсказуемый результат, 
опираясь на одни и те же входящие данные. Может быть такая ситуация что 200 раз мы вызовем эту функцию и данные на сервере будут одними, а когда вызовем 201 они 
поменяются, а значит принцип чистой функции будет нарушен.

Мы можем данный блок поместить внутрь функции getUsersFromServer() внутри данной презентационной компоненты и добавить кнопку "Get users" по нажатия на которую, с помощью
onClick={} мы будем вызывать данную функцию и отображать пользователей на странице. Т.е. код будет выглядеть так:

let getUsersFromServer = () => {
    if (props.users.length === 0) {
        axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
            let users = response.data.items
            props.setUsers(users)
        })
    }
}

...(внутри JSX)

<button
    className={UsersStyles["show_more_btn"]}
    type="button"
    onClick={getUsersFromServer}
>
    Show more
</button>

Однако мы хотим получать пользователей сразу после загрузки страницы без нажатия каких-либо кнопок и к сожалению, сделать это, используя функциональные компоненты, нельзя.
Сейчас для этого используют хуки, но как говорилось ранее, мы будем использовать классовые компоненты, что постепенно придти к хукам.

// 53 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

Классы в JS существуют для быстрого создания однотипных объектов (с помощью метода constructor())

* 
Википедия:
В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и 
реализацию поведения (методы).
*

*
Полезная теория с learn.javascript.ru: 
    Базовый синтаксис - https://learn.javascript.ru/class 
    Наследование - https://learn.javascript.ru/class-inheritance
    Статические свойства и методы - https://learn.javascript.ru/static-properties-methods
    Приватные и защищенные методы и свойства - https://learn.javascript.ru/private-protected-properties-methods
    Расширения встроенных классов - https://learn.javascript.ru/extend-natives
    Проверка класса "instanceof" - https://learn.javascript.ru/instanceof
    Примеси - https://learn.javascript.ru/mixins

Внутри классов не нужно ставить запятые после методов, которые мы задаем внутри, т.к. класс это не привычный нам объект, где свойства разделяются между собой запятой.
*

Важно понимать, что React, когда "видит" вызов функциональной компоненты в коде, вызывает функцию с названием этой компоненты и передает в нее объект необходимых {props},
а когда, React "видит" вызов классовой компоненты он понимает, что изначально, необходимо создать экземпляр (instance) данного класса (т.е. выполнить constructor(props)
передав в него необходимые {props}, чтобы полученный объект имел эти props внутри себя), а затем начинает взаимодействовать с этим instance'ем, вызывая у него метод 
render(), который и должен возвращать JSX-разметку. Также стоит отметить то, что метод render() внутри себя вызывает props с помощью this.props.name, а не обрабатывает их
как приходящие параметры.

Для того чтобы создать классовую компоненту, необходимо использовать наследование классов. В библиотеке React существует специальный класс Component, наследуясь от 
которого мы как бы говорим React'у, что дочерний класс будет являться компонентом, а значит будет подкапотом вызывать метод super(props) внутри дочрнего метода 
constructor(props), т.е.

class Header extends React.Component{
    constructor(props){
        super(props)
    }

    render(){
        ...
    }
}

Метод render для каждой дочерней компоненты является уникальным ввиду того, что каждая компонента должна вернуть собственную разметку, а значит наследовать его от 
родительского React.Component не нужно. Также ввиду наличия у React.Component встроенных методов, дочерние классы (т.е. компоненты) могут пользоваться ими т.к. даныне
методы находятся внутри их прототипа вверх по цепочки наследования.

Мы прибегнули к созданию классовой компоненты с целью решить вопрос нарушения принципа чистой функции в нашем проекте. Т.к. сейчас мы выполняем внутри функциональной 
компоненты другую функцию, загружающую пользователей с сервера. Такие функции (внутренние) внутри классовой компоненты являются методами класса и не задаются через 
ключевые слова let, const, var. 

Ввиду того, что существуют разные синтаксисы к опредлению методов классов, такие как:

sayHi(){
    ...
}

и вариант с стрелочной функцией (у которой нет контекста this, поэтому раньше это был не лучший синтаксис для создания метода (т.к. контекст терялся и его надо было
постоянно биндить), но сейчас "подкапотку" исправили и можно задавать таким способом):

sayHi = () => {
    ...
}

Теперь перепишем нашу функциональную компоненту на классовую. 
Логика поведения компонентов защита внутри React.Component, и следовательно, когда мы extends'имся от данного класса мы получаем внутри дочернего класса (inheritance'а) 
логику поведения компоненты с помощью доступа к прототипу. Также каждый класс должен определить метод render(), возвращающий JSX-разметку, чтобы React мог запускать 
данную компоненту. 

С помощью метода render() вернем ту же разметку, что возвращала нам функциональная компонента, но с доработками. Ввиду того, что теперь props это часть instance класса,
т.е. часть (свойство в котором лежит объект props) объекта, мы должны обращаться к ним с помощью ключевого слова "this", т.к. предполагается что мы обращаемся к props
конкретного объекта. 
Теперь остается перенести обработчики событий (вспомогательные функции) внутрь данного класса в качестве методов. И, присваивая данные обработчики определенным события 
внутри JSX, нам необходимо также обращаться к ним через ключевое слово this, ввиду того, что мы обращаемся к методам, лежащим внутри данного instance'а. Т.е. теперь наша
компонента выглядит так:

class Users extends React.Component {
    render() {
        return (
            <section className={UsersStyles["users"]}>
                {/* User card */}
                <ul className={UsersStyles["users_list"]}>
                    {
                        this.props.users.map((user) => {
                            return (
                                <li key={user.id} className={UsersStyles["user_card"]}>
                                    {/* Avatar + button */}
                                    <div className={UsersStyles["avatar_and_btn"]}>
                                        <img src={user.photos.small !== null ? (user.photos.small) : BaseUserAvatar} alt="Avatar" />
                                        <button
                                            type="button"
                                            className={user.followed ? UsersStyles["unfollowButton"] : UsersStyles["followButton"]}
                                            data-id={user.id}
                                            onClick={user.followed ? this.handleUnfollowUser : this.handleFollowUser}
                                        >
                                            {user.followed ? "Unfollow" : "Follow"}
                                        </button>
                                    </div>
                                    {/* User information */}
                                    <div className={UsersStyles["user_info"]}>
                                        <div className={UsersStyles["user_name_and_status"]}>
                                            <p className={UsersStyles["user_name"]}>
                                                {user.name}
                                            </p>
                                            <p className={UsersStyles["user_status"]}>
                                                {user.status}
                                            </p>
                                        </div>

                                        <div className={UsersStyles["user_location"]}>
                                            <p className={UsersStyles["city"]}>
                                                {"user.location.city"}
                                            </p>
                                            <p className={UsersStyles["country"]}>
                                                {"user.location.country"}
                                            </p>
                                        </div>
                                    </div>

                                </li>
                            )
                        })
                    }
                </ul>
                {/* Show more btn */}
                <button
                    className={UsersStyles["show_more_btn"]}
                    type="button"
                    onClick={this.getUsersFromServer}
                >
                    Show more
                </button>
            </section>
        );
    }

    getUsersFromServer = () => {
        if (this.props.users.length === 0) {
            axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
                let users = response.data.items
                this.props.setUsers(users)
            })
        }
    }

    handleFollowUser = (event) => {
        let userId = event.target.getAttribute("data-id");
        this.props.follow(userId);
    }

    handleUnfollowUser = (event) => {
        let userId = event.target.getAttribute("data-id");
        this.props.unfollow(userId);
    }
}

ВАЖНО:

Еще раз: когда React видит тег (компонент), например, <Header name={props.user.name} age={22} /> и эта компонента является классовой, он создает instance данного класса,
т.е. объект, т.е. компонента в данном случае не функция, а объект, содержащий внутри себя переданные в качестве атрибутов тега props'ы. Т.е. внутри данного объекта есть
свойство props равное объекту, где свойства - названия атрибутов, а их значения - значения атрибутов. Поэтому когда мы создаем классовую компоненту, мы пишем шаблонную
логику поведения для всех instance'ов, которые могут иметь различные props и внутренние методы, а значит, мы должны обращаться именно к тем props и методам, которыми 
владеет данный объект, поэтому мы и используем ключевое слово this.
Т.к. внутри контейнерной компоненты мы используем connect() внутрь которой закидываем функциональную компоненту, важно отметить, что внутрь этой функции также можно
закидывать и классовую компоненту.

На данный момент приложение работает так как нужно и может показаться, что мы просто поменяли синтаксис, но нет. Принципальное отличие заключается в том, что 
функциональные компоненты (функции) вызываются React'ом и сразу "умирают", а когда мы работает с классовой компонентой, React создает объект в памяти и на каждый 
ререндер не пересоздает его, а просто использует отправляю внутрь измененные props. 
Зачем это нужно? Ранее у нас была проблема, когда мы создали некий Side Effect и получили результат того, что на каждую перерисовку приложения мы выполняли запрос на
сервер, ввиду того, что функция (функциональная компонента) вызывалась при каждом изменении state и чтобы этого не происходило нам пришлось добавлять функционал запроса
по клику на кнопку, но мы на самом деле хотели, чтобы пользователи загружались автоматически при запуске компоненты. Справделиво можно заметить, что то же поведение мы
получаем и сейчас, т.к. на каждой ререндер мы перерисовываем компоненту, а значит не можем сделать так, чтобы запрос выполнялся не по нажатию на кнопку а при загрузке 
самой компоненты. 
Тут стоит отметить, что классовая компонента (объект), в отличие от функциональной, создается всего один раз, а значит метод constructor() класса, создающего данную 
компоненту, вызывается всего один раз, даже несмотря на перерисовки приложения, а это в свою очередь значит, что мы можем реализовать запрос на сервер внутри данного 
метода constructor(), используя super(...arg) + функционал выполнения данного запроса на сервер. Это позволит получать пользователей единожды при загрузке (создании) 
компоненты, не используя нажатие кнопки, а следовательно, мы избегаем создание лишних неудобных пользовательских элементов и можем реализовать функционал данной кнопки
по назначению, т.е. не для загрузки пользователей при открытие раздела "Users", а для подгрузки новых (кнопку "Show more").  
Теперь мы можем полностью избавиться от блока if(){} который мы создавали, что при повторном рендере функциональной компоненты не добавлялись пользователи, если их список
не пуст. 

Обычно AJAX-запросы выполняются вне метода constructor(), а в других местах, но про них речь будет идти позже.
Окончательный вариант компоненты выглядит следующим образом:

class Users extends React.Component {
    constructor(...args) {
        super(...args);

        // Реализация запроса на сервер
        axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
            let users = response.data.items
            this.props.setUsers(users)
        })
    }

    render() {
        return (
            <section className={UsersStyles["users"]}>
                {/* User card */}
                <ul className={UsersStyles["users_list"]}>
                    {
                        this.props.users.map((user) => {
                            return (
                                <li key={user.id} className={UsersStyles["user_card"]}>
                                    {/* Avatar + button */}
                                    <div className={UsersStyles["avatar_and_btn"]}>
                                        <img src={user.photos.small !== null ? (user.photos.small) : BaseUserAvatar} alt="Avatar" />
                                        <button
                                            type="button"
                                            className={user.followed ? UsersStyles["unfollowButton"] : UsersStyles["followButton"]}
                                            data-id={user.id}
                                            onClick={user.followed ? this.handleUnfollowUser : this.handleFollowUser}
                                        >
                                            {user.followed ? "Unfollow" : "Follow"}
                                        </button>
                                    </div>
                                    {/* User information */}
                                    <div className={UsersStyles["user_info"]}>
                                        <div className={UsersStyles["user_name_and_status"]}>
                                            <p className={UsersStyles["user_name"]}>
                                                {user.name}
                                            </p>
                                            <p className={UsersStyles["user_status"]}>
                                                {user.status}
                                            </p>
                                        </div>

                                        <div className={UsersStyles["user_location"]}>
                                            <p className={UsersStyles["city"]}>
                                                {"user.location.city"}
                                            </p>
                                            <p className={UsersStyles["country"]}>
                                                {"user.location.country"}
                                            </p>
                                        </div>
                                    </div>

                                </li>
                            )
                        })
                    }
                </ul>
                {/* Show more btn */}
                <button
                    className={UsersStyles["show_more_btn"]}
                    type="button"
                    onClick={this.zaglushka}
                >
                    Show more
                </button>
            </section >
        );
    }

    zaglushka = () => {
        alert("Заглушка")
    }
    handleFollowUser = (event) => {
        let userId = event.target.getAttribute("data-id");
        this.props.follow(userId);
    }
    handleUnfollowUser = (event) => {
        let userId = event.target.getAttribute("data-id");
        this.props.unfollow(userId);
    }
}

// 54 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

На данный момент, с помощью наследования от React.Component мы создаем класс обладающий методами созданными внутри React.Component, т.к. эти методы доступны в прототипе
дочернего класса. Когда React читает классовую компоненту, он создает объект, которому также доступны данные методы созданные в React.Component в прототипе и далее
работает с ней. 
Такие методы называются "методами жизненного цикла" и соответственно, пока объект (компонента) существует, мы можем взаимодействовать с ней используя эти методы из 
React.Component
В качестве примером таких методов могут выступать componentDidMount() и componentDidUpdate() (их на самом деле гораздо больше, но сейчас остановимся на этих). 
Соответственно, пока компонента живет React управляет ей с помощью данных методов. Для наглядности обратимся к псевдокоду:

let m1 = new Man({
    name: "Мужик",
    age: 38,
})

    *На данному этапе React видит создание инстанца от класса и создает компоненту передавая в нее props*

let jsx = m1.render()

    *В этом месте React заставляет компоненту вернуть JSX (отрендериться)* 

rootDiv.append(jsx)

    *В данном месте React результат вызова компоненты вкладывает в DOM дерево*

m1.componentDidMount()

    *На данном этапе React сообщает компоненте с помощью вызова метода жизненного цикла, что та была вмонтирована в DOM*

Как видно из данного примера React - главный менеджер, который всем рулит. Компонента - простой рабочий, который умеет делать только определенные действия, но иногда
может возникать ситуация, когда например, нам важно передать в компоненту какую-то информацию с целью каким-то образом ее изменить. Для этого и существуют методы 
жизненного цикла. Благодаря им, грубо говоря, React сообщает внутрь компоненты определенную информацию. Например, менеджер говорит работнику, что тот выполнил свою задачу
и может идти домой.
В данном примере мы использовали componentDidMount() для того, чтобы сообщить компоненте, что мы вмонтировали ее в DOM дерево. Такой же метод есть для обратного дейтсвия,
для сообщения компоненте, что мы скоро удалим ее - componentDidUnmount(). Такой метод может быть важен, когда мы перестаем показывать компоненту в приложении, а она в 
свою очередь, например, содержит какой-то setInterval и каждую секунду проверяет не пришло ли сообщение пользователю. Соответственно, с помощью этого метода, мы можем 
"предупредить" компоненту о том, что она не будет показываться и остановить выполнение каких-то операций с целью оптимизировать приложение или нагрузку на сервер.

Для чего все эти предисловия? На прошлом уроке, мы поняли, что выполнять Side Effects, т.е. как в нашем случае, AJAX-запросы, нужно не в методе constructor(). Теперь ясно,
что для таких целей, а именно, выполнения всех Side Effects, прекрасно подходит метод componentDidMount(), который выполняется сразу после создания и запуска компоненты. 
Значит мы можем выполнить в методе какие-то запросы и передать их результат внутрь метода render().

Также важно заметить, что т.к. компонент-объект - это инструкция, как и чистая функция, то его не нужно перерисовывать заново, React просто вызывает в ответ на обновления
данных в state в данном объекте метод render() и передает в метод обновленные props, а значит ему не нужно заново добавлять данную jsx внутрь root. Следовательно, функция
rootDiv.append(jsx) не выполняется при ререндере приложения, а выполняется функция rootDiv.update(jsx) (на псевдокоде). Повторное вмонтирование компоненты не происходит,
а значит метод componentDidMount() не вызывается (т.к. как не было вмонтирования компоненты, значит не было и сообщения внутрь компоненты об этом с помощью 
componentDidMount(), а значит AJAX-запросы которые мы выполняем при изначальном вмонтировании компоненты выполнены не будут). Соответственно, метод componentDidMount()
идеально подходит для того, чтобы реализовывать внутри него функционал, который выполняется только в момент первоначальной отрисовки компоненты.

*
Когда происходит смена компонентов с помощью <Route /> и изменения URL, даже классовый-компонент(объект) "умирает" в момент переключения URL, т.к. этот объект больше не
отображается. Т.е. данное поведение актуально для классовой компоненты, когда она отображается на странице.
*

Теперь остается отрефакторить код и поместить функционал выполнения AJAX-запроса внутрь метода класса componentDidMount()

componentDidMount = () => {
    axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
        let users = response.data.items
        this.props.setUsers(users)
    })
}

Важно также заметить, что теперь наш метод constructor() не выполняет ничего другого кроме, как создание объекта как с помощью родительского метода constructor(), т.е.
они ничем не отличают, а значит этот метод можно не определять, т.к. он и так есть в прототипе дочернего класса.

// 55 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

С целью оптимизации работы сервера, предовращения загрузки базы данных и появления различных ошибок, сервер возвращает данные кусками (страницами). Такое поведение
называется "пагинацией" (pagination) или "разбиением на страницы". Чтобы на запрос пользователей с сайта, которых может быть 100 млн. не возвращать каждому пользователю
огромный набор данных, можно разделить эти данные на части (страницы) и отправлять, например, по 20 пользователей за раз. Для таких целей в URL адресе используются
GET-параметры, которые задают конкретику запросу. Чтобы добавить GET-параметр в URL адрес необходимо в конце строки запроса указать вопросительный знак "?" и после него
уточняющие данные, например, "pageNumber=2", где pageNumber означает по какому критерию (параметру) мы отбираем данные, а "=2" указывает на порядковый номер или значение 
этого параметра. Сервер обрабатывает данный запрос и возвращает нам часть необходимых данных. Пример URL адреса с использованием GET-параметров:

https://basadannyh-egor.com?pageNumber=34

В данном случае мы используем GET-параметр "?pageNumber=34".

Как правило, возникают ситуации, когда нам необходимо для спроектированного UI отображать меньше/больше элементов с сервера. Серверной разработкой занимается backend-ер
и обычно для пагинации прописываются различные варианты взаимодействия, которые мы можем настраивать с помощью URL. Т.е. если сервер отправляет в каждой "page" по 5 
пользователей, а нам надо отобразить только 3 и не больше, то мы можем настроить размер возвращаемой с сервера "page", так же используя GET-параметры.

Такой параметр может называться pageSize, limit, count и т.д. Конкретное название и количество элементов в одной возвращаемой странице указаны в документации к API.
Т.е. URL адрес запроса где мы меняем кол-во возвращаемых элементов может выглядеть так:

https://basadannyh-egor.com?pageNumber=34&limit=3

Соответственно, когда мы используем GET-запрос, единственный способ передавать какие-то данные и инструкции серверу это GET-параметры. В нашем приложении frontend 
спроектирован так, чтобы отображать по 4 пользователя за раз. Значит мы можем создать запрос на сервер с следующим URL:

https://social-network.samuraijs.com/api/1.0/users?page=3&count=4

Если ввести данный адрес в поисковую строку браузера, то мы получим JSON файл с 4 пользователями.
*Параметры разделяются амперсандом "&"*

В документации к API, которую мы используем указано: "count: (integer - default: 10 - maximum: 100)" - что означает, что по умолчанию размер страницы 10 и максимально
возможный к запросу размер page = 100.

*
Сейчас порядок отрисовки пользователей с сервера такой:
    1. React находит классовую презентационную компоненту
    2. Создает объект (instance) этого класса - это и есть компонента (которая в отличие от функциональной живет долго и не пересоздается на каждый вызов ререндера)
    3. Выполняет метод render(), т.е. генерирует JSX, опираясь на те props, которые лежат внутри объекта-компоненты с момента создания
    4. Добавляет полученный JSX в VDOM, а затем и в DOM-дерево (на данном этапе пользователи не отображаются т.к. мы не получили их с сервера)
    5. Вызывает метод componentDidMount(), сообщая компоненте-объекту, что он был отрисован, а также выполняет запрос на сервер, результаты которого добавляются в state
    6. В ответ на изменение state, React выполняет ререндер приложения и пользователи приходят в качестве props внутрь компоненты.
    7. Компонента перерисовывается, опираясь на обновленные props.
*

Если мы хотим отобразить количество страниц пользователей, (т.е. всего, например, 100 пользователей на сервере, а мы отображаем 5, значит страниц между которыми можно
переключатсья всего 20) нам нужно общее кол-во пользователей разделить на размер страницы. Соответственно, для реализации такого функционала, нам необходимо передать 
внутрь презентационной компоненты общее кол-во пользователей и размер страницы. Если с размером страницы все просто (и его можно захардкодить), то что делать с 
количеством пользователей, ведь мы не знаем на моменте инициализации данных в initialState это кол-во, т.к. запрос на сервер еще не был отправлен. Для решения этого 
вопроса достаточно в initialState полю quantityOfUsers задать значение 0 и присвоить ему новое значение внутри метода componentDidMount() после выполнения запроса, который
и позволит присвоить общее количество пользователей необходимому свойству в state.

Чтобы определять какая страница пользователей отображена в текущий момент времени на странице, мы должны хранить эти данные где-то. Логично, что единственное подходящее 
место для информации о текущей странице и общем количестве таких страниц (разделов с пользователями) - это state. Поэтому создадим данные поля внутри initialState у 
reducer'а блока users.

Соотвтественно, данные свойства необходимо "прокинуть" внутрь компоненты через props. В нашем случае делается это с помощью функции mapStateToProps() которую мы определяем
внутри контейнерной компоненты. 

Т.к. нам необходимо выполнить данный функционал во время рендера компоненты, то логичным будет, считать количество страниц пользователей внутри метода рендер.

На данном этапе:
1. Рендерится компонента с пустым массивом и без страниц опираясь на изначальный initialState
2. После рендера React вызывает метод componentDidMount(), внутри которого мы получаем данные с сервера и с помощью функций взаимодейсвтия со store, переданных из контейнерной
компоненты с помощью mapDispatchToProps(), изменяем state (добавляем пользователей в массив и присваиваем общее кооличество всех пользователей свойству quantityOfUsers (по 
умолчанию равно 0))
3. В ответ на изменение state происходит ререндер компоненты, которая опирается на измененный state
4. В методе рендер (в момент рендера этой компоненты) мы расчитываем кол-во страниц для отображения, исходя из количество пользователей, пришедших в ответе с сервера и размера
страницы заданного внутри initialState по умолчанию
5. На странице отображается количество необходимых страниц для отображения всех пользователей и сами пользователи первой страницы в максимальном количестве определенном
внутри документации API.  

Это происходит, т.к. в нашем запросе на сервер не используются GET-параметры и мы никак не регулируем наш запрос исходя из полей currentPage и pageSize.
Для того чтобы реализовать такой функционал, нам необходимо использовать динамические строки для создания URL. Т.е. запрос на сервер должен зависеть от состояния, а именно
от поля pageSize должно зависеть максимальное кол-во пользователей для оторбажения на одной странице, а от поля currentPage должно зависеть та часть всех пользователей, 
которую мы запрашиваем с сервера, т.е. как указано в документации API - это параметр page должен быть равен нашему значению currentPage.

Соответственно, теперь URL запрос должен выглядеть так:

`https://social-network.samuraijs.com/api/1.0/users?page=${this.props.currentPage}&count=${this.props.pageSize}`

Однако ввиду того, что метод componentDidMount() вызывается всего единожды при первоначальном вмонтировании компоненты в DOM дерево, при клике на номер страницы, у нас
ничего не будет изменятся, т.к. при нажатии на номер страницы, у нас меняется только значение внутри поля state, но запрос на сервер не выполняется, т.к. этот функционал
реализован только для первого вмонтирования компоненты. Для решения этой задачи существует метод componentDidUpdate(), который вызывается в ответ на каждое обновление 
компоненты в отличие от componentDidMount()


// 56 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

Ввиду того, что сейчас наша "презентационная" компонента выполняет side-эффекты, она не является чистой функцией. Использование чистых функций - один из главных принципов
React. Контейнерная компонента создана для того чтобы забирать всю грязную работу на себя, следовательно, функционал выполнения AJAX-запросов, нужно вынести куда-то в 
другое место. Поэтому наша компонента Users превращается в контейнерную, задачей которой является отрисовка презентационной (чистой) компоненты и создание AJAX-запросов.
Т.е. теперь у нас 2 контейнерных компоненты:
    первая (Store) - созданная с помощью функции connect(), производит взаимодействие со Store с помощью функций mapDispatchToProps(), mapStateToProps() и вызывает вторую 
    контейнерную компоненту
    вторая (API) - вызывается первой контейнерной компонентой и выполняет AJAX-запросы передавая их результат в презентационную компоненту, которую сама же и отрисовывает

Теперь презентационную компоненту мы можем сделать функциональной и чистой, т.е. такой, какой она была до поялвения в логике приложения AJAX-запросов.

Стоит отметить то, что теперь у нас функциональная компонента, а следовательно, у нас нет контекста this, который был в классовой, поэтому запись вида "this.props" нужно
исправить на "props"

Теперь возникла ситуация, когда мы передаем из первой (Store) контейнерной компоненты все props необходимые и второй (API) контейнерной компоненте, и презентационной 
компоненте. Следовательно, наша презентационная компонента работает не со всеми props пришедшими из первой контейнерной компоненты, а только с их частью, т.к. вторую часть
использует вторая контейнерная компонента (API) (далее КК). Нам остается только передать нужные props из 2-ой КК в нашу презентационную компоненту. 

Теперь мы можем объединить две контейнерные компоненты внути первой, т.к. во второй у нас остался класс, который мы можем просто перенсти в первую контейнерную компоненту.
И получается что наша контейнерная (объединенная) компонента и реализует связь со Store с помощью Context API и функции connect() и также выполняет side-эффекты с помощью 
класса, который также отрисовывает презентационную компоненту.


// 57 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

Preloader - очень важен в веб-приложениях, т.к. позволяет показать пользователю, что в данный момент происходят какие-то действия и не нагружать тем самым систему, например,
излишними запросами на сервер. Т.к. preloader - это часть интерфейса, то он должен отображаться исходя из определенных состояний state.
Ввиду того, что сейчас у нас AJAX-запросы выполняет UI, мы должны в момент выполнения запроса передавать в state информацию о том, что запрос выполняется, следовательно, 
state будет в ответ на изменение передавать данные в UI, опираясь на которые мы и отрисуем "крутилку". Соответственно, когда выполнение запроса завершено, мы должны передать
информацию об этом в state, чтобы изменить, например, состояние выполнения загрузки и на основании обновленных данных перерисовать UI, но уже без "куртилки". 

Для реализации такого функционала, нам необходимо использовать условные выражение внутри метода render() классовой компоненты, чтобы отображать либо крутилку, либо контент.
Также необходимо:
    - добавить значение по умолчанию в initialState
    - создать case внутри конструкции switch (внутри dispatch)
    - создать функцию ...ActionCreator
    - создать соответствующую функцию и передать ее с помощью mapDispatchToProps
    - вызвать данную функцию изменения состояния loading внутри презентационной компоненты в моменты начала и конца запроса

В данный момент ввиду хорошей скорости интернета preloader мы почти не видим на странице. Для более наглядного отображения мы можем искусственно понизить скорость с помощью:
    Консоль -> Network -> Throttling -> Slow 3G

Также можно заметить, что данный preloader логично вынести в отдельную компоненту, чтобы использовать на других страницах.