// 51 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

На данном этапе, нам необходимо избавиться от фиксированных (захардкоженых) пользователей, которых мы добавляем с помощью setUsers()
Для того, чтобы писать запросы на сервер, необходимо использовать библиотеку "axios", а следовательно, нам необходимо её установить с помощью команды "npm i axios --save"
и импортировать с помощью "import * as axios from "axios";" (запись "* as axios" означает, что мы хотим импортировать всё что имеет название axios внутри библиотке, как
"axios" в наш проект).
Непосредственно создание запросов мы реализуем внутри презентационной компоненты в блоке if(){}, который мы реализовали на прошлом уроке.

Любая серверная API (определенные endpoint'ы) имеют базовый URL-адрес, который не изменяется относительно типа выполняемого запроса (т.е. часть URL запроса всегда 
фиксирована и эта часть и называется "базовый URL")

Наш базовый URL: "https://social-network.samuraijs.com/api/1.0"

Если мы хотим обратиться за конкретными ресурсами (данными), то мы обращаемся к конкретному endpoint'у на сервер, например, users/. Таким образом, что получить данные с 
сервера мы знаем, что надо использовать GET-запрос к endpoint'у users/, предварительно в URL-адресе запроса указать базовый URL. Т.е. для того, чтобы создать запрос, нам
необходимо воспользоваться следующим синтаксисом:

axios.get("https://social-network.samuraijs.com/api/1.0/users")

Функция get("URL-адрес") содержит под капотом функционал выполнения запроса на сервер и оборачивания его в промис. Соответственно, результат вызова данной функции - промис
и для того, чтобы обработать содержащийся в этом промисе результат выполнения запроса, нам необходимо вызвать у данного промиса метод then(), который принимает в себя
в качестве параметра сам результат выполнения запроса (response).
Синтаксис:

axios.get("https://social-network.samuraijs.com/api/1.0/users").then( (response)=>{
    *обработка ответа сервера*
} )

Логично, что данный функционал мы должны поместить внутрь блока if(props.users.length === 0){...}, ввиду того, что первоначальную установку пользователей функцией 
setUsers() мы будем выполнять автоматически (без нажатия на кнопку "Show more")

По данному запросу мы получаем объект (response), который содержит в себе большое количество свойств, а именно:

config: {transitional: {…}, adapter: Array(2), transformRequest: Array(1), transformResponse: Array(1), timeout: 0, …}
data: {items: Array(10), totalCount: 26169, error: null}
headers: AxiosHeaders {cache-control: 'no-cache', content-length: '1260', content-type: 'application/json; charset=utf-8', expires: '-1', pragma: 'no-cache'}
request: XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …}
status: 200
statusText: ""

Это объект ответа сервера (впринципе данные характеризующие сам запрос) и для того, чтобы добраться до данных, сидящих внутри этого объекта, нам необходимо обратиться к 
полю "data" (данные с сервера, полученный по данному запросу с сервера)

data: {
    error: null,
    items: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}],
    totalCount: 26169,
}

Значит на данном моменте, необходимые объекты пользователей (для отображения на странице) находятся внутри response.data.items, а значит в методе then(), вызванном после
выполнения запроса, мы должны обработать ответ сервера и получить эти данные, а затем передать их в функцию setUsers(), т.е.:

if (props.users.length === 0) {
    axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
        let users = response.data.items
        props.setUsers(users)
    })
}

Однако на данном моменте мы получим ошибку, ввиду того, что обрабатываем внутри презентационной компоненты свойства объекта пользователя, которых на самом деле у этих
объектов нет, например, "lcountry", "city" и др. Так происходит ввиду того, что полученный с сервера объекты имеют следующие поля:

{
    name: "Matuxa",
    id: 31161,
    uniqueUrlName: null,
    photos: {
        small: null,
        large: null
    },
    status: null,
    followed: false
}

А обработнные ранее объекты презентационной компоненты имели следующие:

{ 
    id: "1", 
    avatarURL: "https//worldpodium.ru/sites/default/files/styles/400x400sc/public/gosha_rubchinskiy.jpg?itok=q5UPHzac", 
    firstName: "Gosha", 
    secondName: "Rubchinskiy", 
    status: "I'm a big lover of potatoes", followed: true, 
    location: { 
        country: "Russia", 
        city: "Moscow" 
    }
}

Чтобы таких казусов не возникало на реалиных проектах, необходимо разрабатывать презентационные компоненты исходя из того формата данных, который разработан на сервере.
Т.е. изначально, нужно смотреть на то, какие объекты пользователя лежат на сервере и какие поля оин имеют, чтобы не создавать лишние ошибки и дополнительную работу себе
или бэкендеру. Исходя из этого, нам необходимо переписать функционал презентационной компоненты под текущие данные с сервера.

Для обработки аватарки пользователя, мы можем использовать функционал тернанрных выражений, чтобы в случае если у объекта пользователя нет собственной установленной 
фотографии мы возвращали фиксированную (серую) заглушку. Для этого, эту заглушку нужно добавить в папку проекта и импортировать внутрь презентационной компоненты. 
Соответственно, синтаксис будет следующим:

import BaseUserAvatar from "../../images/user_without_photo.jpg";
...
<img src={user.photos.small !== null ? (user.photos.small) : BaseUserAvatar} alt="Avatar" />

ВАЖНО:
В прошлом уроке мы допустили серьезную погрешность, т.к. выполняем запрос внутри презентационной компоненты, нарушая тем самым принцип чистых функций. Теперь при каждом
ререндере компоненты мы должны выполнять запрос на сервер (хоть мы и избежали этого поведения с помощью блока if(){...}, всё равно факт наличия дополнительного 
функционала непредусмотренного презентационной компонентой остается). Для того чтобы решить данную проблему, мы будем использовать классовые компоненты. Важно отметить, 
что сейчас данный вопрос решается с помощью хуков, но мы будем все равно использовать устаревшие классовые компоненты и постепенно придем к хукам (т.к. понимание хуков
строится на понимании классовых компонентов).

// 52 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

Чтобы функция оставалась чистой, мы не должны, как в уроке ранее, допускать выполнение каких-либо "Side Effects", т.е., например, запросов на сервер, модификаций входящих
данных (т.к. функция работает только в пределах своей области ответственности и не может изменять хранящиеся в другом месте данные), изменения DOM дерева и др (скриншот
приложен в папку проекта).
Исходя из выше сказанного, в нашем проекте презентационная компонента <Users /> на данном этапе выполняет следующий Side Effect:

if (props.users.length === 0) {
    axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
        let users = response.data.items
        props.setUsers(users)
    })
}

Исходя из того, что у нас нет гарантий того, что данные на сервере не изменятся, мы не можем утрверждать что данный функционал всегда вернет предсказуемый результат, 
опираясь на одни и те же входящие данные. Может быть такая ситуация что 200 раз мы вызовем эту функцию и данные на сервере будут одними, а когда вызовем 201 они 
поменяются, а значит принцип чистой функции будет нарушен.

Мы можем данный блок поместить внутрь функции getUsersFromServer() внутри данной презентационной компоненты и добавить кнопку "Get users" по нажатия на которую, с помощью
onClick={} мы будем вызывать данную функцию и отображать пользователей на странице. Т.е. код будет выглядеть так:

let getUsersFromServer = () => {
    if (props.users.length === 0) {
        axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
            let users = response.data.items
            props.setUsers(users)
        })
    }
}

...(внутри JSX)

<button
    className={UsersStyles["show_more_btn"]}
    type="button"
    onClick={getUsersFromServer}
>
    Show more
</button>

Однако мы хотим получать пользователей сразу после загрузки страницы без нажатия каких-либо кнопок и к сожалению, сделать это, используя функциональные компоненты, нельзя.
Сейчас для этого используют хуки, но как говорилось ранее, мы будем использовать классовые компоненты, что постепенно придти к хукам.

// 53 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

Классы в JS существуют для быстрого создания однотипных объектов (с помощью метода constructor())

* 
Википедия:
В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и 
реализацию поведения (методы).
*

*
Полезная теория с learn.javascript.ru: 
    Базовый синтаксис - https://learn.javascript.ru/class 
    Наследование - https://learn.javascript.ru/class-inheritance
    Статические свойства и методы - https://learn.javascript.ru/static-properties-methods
    Приватные и защищенные методы и свойства - https://learn.javascript.ru/private-protected-properties-methods
    Расширения встроенных классов - https://learn.javascript.ru/extend-natives
    Проверка класса "instanceof" - https://learn.javascript.ru/instanceof
    Примеси - https://learn.javascript.ru/mixins

Внутри классов не нужно ставить запятые после методов, которые мы задаем внутри, т.к. класс это не привычный нам объект, где свойства разделяются между собой запятой.
*

Важно понимать, что React, когда "видит" вызов функциональной компоненты в коде, вызывает функцию с названием этой компоненты и передает в нее объект необходимых {props},
а когда, React "видит" вызов классовой компоненты он понимает, что изначально, необходимо создать экземпляр (instance) данного класса (т.е. выполнить constructor(props)
передав в него необходимые {props}, чтобы полученный объект имел эти props внутри себя), а затем начинает взаимодействовать с этим instance'ем, вызывая у него метод 
render(), который и должен возвращать JSX-разметку. Также стоит отметить то, что метод render() внутри себя вызывает props с помощью this.props.name, а не обрабатывает их
как приходящие параметры.

Для того чтобы создать классовую компоненту, необходимо использовать наследование классов. В библиотеке React существует специальный класс Component, наследуясь от 
которого мы как бы говорим React'у, что дочерний класс будет являться компонентом, а значит будет подкапотом вызывать метод super(props) внутри дочрнего метода 
constructor(props), т.е.

class Header extends React.Component{
    constructor(props){
        super(props)
    }

    render(){
        ...
    }
}

Метод render для каждой дочерней компоненты является уникальным ввиду того, что каждая компонента должна вернуть собственную разметку, а значит наследовать его от 
родительского React.Component не нужно. Также ввиду наличия у React.Component встроенных методов, дочерние классы (т.е. компоненты) могут пользоваться ими т.к. даныне
методы находятся внутри их прототипа вверх по цепочки наследования.

Мы прибегнули к созданию классовой компоненты с целью решить вопрос нарушения принципа чистой функции в нашем проекте. Т.к. сейчас мы выполняем внутри функциональной 
компоненты другую функцию, загружающую пользователей с сервера. Такие функции (внутренние) внутри классовой компоненты являются методами класса и не задаются через 
ключевые слова let, const, var. 

Ввиду того, что существуют разные синтаксисы к опредлению методов классов, такие как:

sayHi(){
    ...
}

и вариант с стрелочной функцией (у которой нет контекста this, поэтому раньше это был не лучший синтаксис для создания метода (т.к. контекст терялся и его надо было
постоянно биндить), но сейчас "подкапотку" исправили и можно задавать таким способом):

sayHi = () => {
    ...
}

Теперь перепишем нашу функциональную компоненту на классовую. 
Логика поведения компонентов защита внутри React.Component, и следовательно, когда мы extends'имся от данного класса мы получаем внутри дочернего класса (inheritance'а) 
логику поведения компоненты с помощью доступа к прототипу. Также каждый класс должен определить метод render(), возвращающий JSX-разметку, чтобы React мог запускать 
данную компоненту. 

С помощью метода render() вернем ту же разметку, что возвращала нам функциональная компонента, но с доработками. Ввиду того, что теперь props это часть instance класса,
т.е. часть (свойство в котором лежит объект props) объекта, мы должны обращаться к ним с помощью ключевого слова "this", т.к. предполагается что мы обращаемся к props
конкретного объекта. 
Теперь остается перенести обработчики событий (вспомогательные функции) внутрь данного класса в качестве методов. И, присваивая данные обработчики определенным события 
внутри JSX, нам необходимо также обращаться к ним через ключевое слово this, ввиду того, что мы обращаемся к методам, лежащим внутри данного instance'а. Т.е. теперь наша
компонента выглядит так:

class Users extends React.Component {
    render() {
        return (
            <section className={UsersStyles["users"]}>
                {/* User card */}
                <ul className={UsersStyles["users_list"]}>
                    {
                        this.props.users.map((user) => {
                            return (
                                <li key={user.id} className={UsersStyles["user_card"]}>
                                    {/* Avatar + button */}
                                    <div className={UsersStyles["avatar_and_btn"]}>
                                        <img src={user.photos.small !== null ? (user.photos.small) : BaseUserAvatar} alt="Avatar" />
                                        <button
                                            type="button"
                                            className={user.followed ? UsersStyles["unfollowButton"] : UsersStyles["followButton"]}
                                            data-id={user.id}
                                            onClick={user.followed ? this.handleUnfollowUser : this.handleFollowUser}
                                        >
                                            {user.followed ? "Unfollow" : "Follow"}
                                        </button>
                                    </div>
                                    {/* User information */}
                                    <div className={UsersStyles["user_info"]}>
                                        <div className={UsersStyles["user_name_and_status"]}>
                                            <p className={UsersStyles["user_name"]}>
                                                {user.name}
                                            </p>
                                            <p className={UsersStyles["user_status"]}>
                                                {user.status}
                                            </p>
                                        </div>

                                        <div className={UsersStyles["user_location"]}>
                                            <p className={UsersStyles["city"]}>
                                                {"user.location.city"}
                                            </p>
                                            <p className={UsersStyles["country"]}>
                                                {"user.location.country"}
                                            </p>
                                        </div>
                                    </div>

                                </li>
                            )
                        })
                    }
                </ul>
                {/* Show more btn */}
                <button
                    className={UsersStyles["show_more_btn"]}
                    type="button"
                    onClick={this.getUsersFromServer}
                >
                    Show more
                </button>
            </section>
        );
    }

    getUsersFromServer = () => {
        if (this.props.users.length === 0) {
            axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
                let users = response.data.items
                this.props.setUsers(users)
            })
        }
    }

    handleFollowUser = (event) => {
        let userId = event.target.getAttribute("data-id");
        this.props.follow(userId);
    }

    handleUnfollowUser = (event) => {
        let userId = event.target.getAttribute("data-id");
        this.props.unfollow(userId);
    }
}

ВАЖНО:

Еще раз: когда React видит тег (компонент), например, <Header name={props.user.name} age={22} /> и эта компонента является классовой, он создает instance данного класса,
т.е. объект, т.е. компонента в данном случае не функция, а объект, содержащий внутри себя переданные в качестве атрибутов тега props'ы. Т.е. внутри данного объекта есть
свойство props равное объекту, где свойства - названия атрибутов, а их значения - значения атрибутов. Поэтому когда мы создаем классовую компоненту, мы пишем шаблонную
логику поведения для всех instance'ов, которые могут иметь различные props и внутренние методы, а значит, мы должны обращаться именно к тем props и методам, которыми 
владеет данный объект, поэтому мы и используем ключевое слово this.
Т.к. внутри контейнерной компоненты мы используем connect() внутрь которой закидываем функциональную компоненту, важно отметить, что внутрь этой функции также можно
закидывать и классовую компоненту.

На данный момент приложение работает так как нужно и может показаться, что мы просто поменяли синтаксис, но нет. Принципальное отличие заключается в том, что 
функциональные компоненты (функции) вызываются React'ом и сразу "умирают", а когда мы работает с классовой компонентой, React создает объект в памяти и на каждый 
ререндер не пересоздает его, а просто использует отправляю внутрь измененные props. 
Зачем это нужно? Ранее у нас была проблема, когда мы создали некий Side Effect и получили результат того, что на каждую перерисовку приложения мы выполняли запрос на
сервер, ввиду того, что функция (функциональная компонента) вызывалась при каждом изменении state и чтобы этого не происходило нам пришлось добавлять функционал запроса
по клику на кнопку, но мы на самом деле хотели, чтобы пользователи загружались автоматически при запуске компоненты. Справделиво можно заметить, что то же поведение мы
получаем и сейчас, т.к. на каждой ререндер мы перерисовываем компоненту, а значит не можем сделать так, чтобы запрос выполнялся не по нажатию на кнопку а при загрузке 
самой компоненты. 
Тут стоит отметить, что классовая компонента (объект), в отличие от функциональной, создается всего один раз, а значит метод constructor() класса, создающего данную 
компоненту, вызывается всего один раз, даже несмотря на перерисовки приложения, а это в свою очередь значит, что мы можем реализовать запрос на сервер внутри данного 
метода constructor(), используя super(...arg) + функционал выполнения данного запроса на сервер. Это позволит получать пользователей единожды при загрузке (создании) 
компоненты, не используя нажатие кнопки, а следовательно, мы избегаем создание лишних неудобных пользовательских элементов и можем реализовать функционал данной кнопки
по назначению, т.е. не для загрузки пользователей при открытие раздела "Users", а для подгрузки новых (кнопку "Show more").  
Теперь мы можем полностью избавиться от блока if(){} который мы создавали, что при повторном рендере функциональной компоненты не добавлялись пользователи, если их список
не пуст. 

Обычно AJAX-запросы выполняются вне метода constructor(), а в других местах, но про них речь будет идти позже.
Окончательный вариант компоненты выглядит следующим образом:

class Users extends React.Component {
    constructor(...args) {
        super(...args);

        // Реализация запроса на сервер
        axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
            let users = response.data.items
            this.props.setUsers(users)
        })
    }

    render() {
        return (
            <section className={UsersStyles["users"]}>
                {/* User card */}
                <ul className={UsersStyles["users_list"]}>
                    {
                        this.props.users.map((user) => {
                            return (
                                <li key={user.id} className={UsersStyles["user_card"]}>
                                    {/* Avatar + button */}
                                    <div className={UsersStyles["avatar_and_btn"]}>
                                        <img src={user.photos.small !== null ? (user.photos.small) : BaseUserAvatar} alt="Avatar" />
                                        <button
                                            type="button"
                                            className={user.followed ? UsersStyles["unfollowButton"] : UsersStyles["followButton"]}
                                            data-id={user.id}
                                            onClick={user.followed ? this.handleUnfollowUser : this.handleFollowUser}
                                        >
                                            {user.followed ? "Unfollow" : "Follow"}
                                        </button>
                                    </div>
                                    {/* User information */}
                                    <div className={UsersStyles["user_info"]}>
                                        <div className={UsersStyles["user_name_and_status"]}>
                                            <p className={UsersStyles["user_name"]}>
                                                {user.name}
                                            </p>
                                            <p className={UsersStyles["user_status"]}>
                                                {user.status}
                                            </p>
                                        </div>

                                        <div className={UsersStyles["user_location"]}>
                                            <p className={UsersStyles["city"]}>
                                                {"user.location.city"}
                                            </p>
                                            <p className={UsersStyles["country"]}>
                                                {"user.location.country"}
                                            </p>
                                        </div>
                                    </div>

                                </li>
                            )
                        })
                    }
                </ul>
                {/* Show more btn */}
                <button
                    className={UsersStyles["show_more_btn"]}
                    type="button"
                    onClick={this.zaglushka}
                >
                    Show more
                </button>
            </section >
        );
    }

    zaglushka = () => {
        alert("Заглушка")
    }
    handleFollowUser = (event) => {
        let userId = event.target.getAttribute("data-id");
        this.props.follow(userId);
    }
    handleUnfollowUser = (event) => {
        let userId = event.target.getAttribute("data-id");
        this.props.unfollow(userId);
    }
}

// 54 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

На данный момент, с помощью наследования от React.Component мы создаем класс обладающий методами созданными внутри React.Component, т.к. эти методы доступны в прототипе
дочернего класса. Когда React читает классовую компоненту, он создает объект, которому также доступны данные методы созданные в React.Component в прототипе и далее
работает с ней. 
Такие методы называются "методами жизненного цикла" и соответственно, пока объект (компонента) существует, мы можем взаимодействовать с ней используя эти методы из 
React.Component
В качестве примером таких методов могут выступать componentDidMount() и componentDidUpdate() (их на самом деле гораздо больше, но сейчас остановимся на этих). 
Соответственно, пока компонента живет React управляет ей с помощью данных методов. Для наглядности обратимся к псевдокоду:

let m1 = new Man({
    name: "Мужик",
    age: 38,
})

    *На данному этапе React видит создание инстанца от класса и создает компоненту передавая в нее props*

let jsx = m1.render()

    *В этом месте React заставляет компоненту вернуть JSX (отрендериться)* 

rootDiv.append(jsx)

    *В данном месте React результат вызова компоненты вкладывает в DOM дерево*

m1.componentDidMount()

    *На данном этапе React сообщает компоненте с помощью вызова метода жизненного цикла, что та была вмонтирована в DOM*

Как видно из данного примера React - главный менеджер, который всем рулит. Компонента - простой рабочий, который умеет делать только определенные действия, но иногда
может возникать ситуация, когда например, нам важно передать в компоненту какую-то информацию с целью каким-то образом ее изменить. Для этого и существуют методы 
жизненного цикла. Благодаря им, грубо говоря, React сообщает внутрь компоненты определенную информацию. Например, менеджер говорит работнику, что тот выполнил свою задачу
и может идти домой.
В данном примере мы использовали componentDidMount() для того, чтобы сообщить компоненте, что мы вмонтировали ее в DOM дерево. Такой же метод есть для обратного дейтсвия,
для сообщения компоненте, что мы скоро удалим ее - componentDidUnmount(). Такой метод может быть важен, когда мы перестаем показывать компоненту в приложении, а она в 
свою очередь, например, содержит какой-то setInterval и каждую секунду проверяет не пришло ли сообщение пользователю. Соответственно, с помощью этого метода, мы можем 
"предупредить" компоненту о том, что она не будет показываться и остановить выполнение каких-то операций с целью оптимизировать приложение или нагрузку на сервер.

Для чего все эти предисловия? На прошлом уроке, мы поняли, что выполнять Side Effects, т.е. как в нашем случае, AJAX-запросы, нужно не в методе constructor(). Теперь ясно,
что для таких целей, а именно, выполнения всех Side Effects, прекрасно подходит метод componentDidMount(), который выполняется сразу после создания и запуска компоненты. 
Значит мы можем выполнить в методе какие-то запросы и передать их результат внутрь метода render().

Также важно заметить, что т.к. компонент-объект - это инструкция, как и чистая функция, то его не нужно перерисовывать заново, React просто вызывает в ответ на обновления
данных в state в данном объекте метод render() и передает в метод обновленные props, а значит ему не нужно заново добавлять данную jsx внутрь root. Следовательно, функция
rootDiv.append(jsx) не выполняется при ререндере приложения, а выполняется функция rootDiv.update(jsx) (на псевдокоде). Повторное вмонтирование компоненты не происходит,
а значит метод componentDidMount() не вызывается (т.к. как не было вмонтирования компоненты, значит не было и сообщения внутрь компоненты об этом с помощью 
componentDidMount(), а значит AJAX-запросы которые мы выполняем при изначальном вмонтировании компоненты выполнены не будут). Соответственно, метод componentDidMount()
идеально подходит для того, чтобы реализовывать внутри него функционал, который выполняется только в момент первоначальной отрисовки компоненты.

*
Когда происходит смена компонентов с помощью <Route /> и изменения URL, даже классовый-компонент(объект) "умирает" в момент переключения URL, т.к. этот объект больше не
отображается. Т.е. данное поведение актуально для классовой компоненты, когда она отображается на странице.
*

Теперь остается отрефакторить код и поместить функционал выполнения AJAX-запроса внутрь метода класса componentDidMount()

componentDidMount = () => {
    axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
        let users = response.data.items
        this.props.setUsers(users)
    })
}

Важно также заметить, что теперь наш метод constructor() не выполняет ничего другого кроме, как создание объекта как с помощью родительского метода constructor(), т.е.
они ничем не отличают, а значит этот метод можно не определять, т.к. он и так есть в прототипе дочернего класса.