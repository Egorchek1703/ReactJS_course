// 2 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
NodeJS - платформа для взаимодейтсвия с помощью JavaScript, например, с файловой системой, с серверной частью (с помощью NodeJS и создается программа для сервера) и т.д.

Node.js — программная платформа, основанная на движке V8 (компилирующем JavaScript в машинный код), превращающая JavaScript из узкоспециализированного языка в язык 
общего назначения. Node.js добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API, написанный на C++, подключать другие внешние 
библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода.

NodeJS содержит в себе несколько различных написанных программ (пакетов), которые устанавливаются с помощью рабочей лошидки NodeJS - NPM (nodejs packages manager)
Для запуска таких программ существует другая рабочаяя лошадка - NPX.

// 3 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Установка - https://nodejs.org/en/download

// 4 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Открываем консоль NodeJS (command prompt) и открываем папку в которой будем создавать наш проект
По умолчанию консоль открыта на диске C. Чтобы сменить диск необходимо написать имя диска и двоеточие "d:" и нажать Enter

Теперь чтобы перейти в необходимую нам директорию (сменить её) необходимо написать cd (change directory) и указать путь к папке (директории)
Чтобы поднять на уровень выше (выйти из папки) необходимо написать "cd ..", а чтобы провалиться "cd имя-папки/имя-внутренней-папки" и т.д.

После установик пакета запустить проект с помощью npm start не получится т.к. мы остались в предыдущей директории где лежит не сам проект (пакет)
а лишь папка с этим проектом, а значит нам необходимо провалиться в папку с проектом (там лежит package.json - набор настроек проекта, без которого
проект не запуститься)

// 5 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
JSX - это своегорода синтаксический сахар позволяющий писать HTML разметку внутри JavaScript кода
Один JavaScript файл (компонент) должен быть представлен либо функцией которая возвращает HTML разметку с помощью return с логикой внутри себя, 
либо класс с методом render(). Важно что родительский элемент должен быть только один (нельзя вернуть два и болле тега на первом уровне вложенности)


// 6 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
SPA - крутая концепция, т.к. позволяет не запращивать у сервера постоянно новый HTML документ при каждой перезагрузки страницы, а разово загрузить
страницу и отправлять с помощью большого количества JS подгруженного изначально AJAX-запросы серверу, в ответ на которые тот шлет JSON объекты с 
данными. Теперь если вам на странице с сообщениями (например в ВК) пришло новое сообщение, нет необходимости рендерить весь HTML документ заново.
Мы просто считываем данные с JSON (response) от сервера и отображаем их на странице. Таким образом SPA позволяет экономить ресурсы и компьютера и 
сервера одновременно.
Страница всегда одна даже если с раздела "Сообщения" необходимо перейти в раздел "Feed". Формально URL меняется, но запрашиваем мы не новый HTML,
а также данные JSON и просто заново отрисовываем первоначально загруженную страницу.

Также ввиду того, что на мобильной разработке приложений не используется HTML документы, мы не можем использовать обычный подход отправки страницы
целиком в браузере клиенту, т.к. этот сервер будет заточен под генерацию HTML, но когда мы используем в качестве обмена информацией JSON объекты,
то мы можем использовать один и тот же сервер и для мобильных приложений т.к. они способны отображать данные прочитанные из JSON

Картинка приложена к конспекту в папке 

// 7 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Компонент - это функция, возвращающая JSX разметку. Она может выполнять внутри себя логику и т.д. но обязательно должна вернуть JSX (содержание
которого может зависеть от логики внутри функции-компонента)

Компоненты можно вкладывать друг в друга, ведь они являются неким аналогом HTML-тега только уже в с вложенным контентом и другими тегами. Мы конечно
можем создать в одном файле App.js все компоненты сайта и объекдинить их в общую обертку, но тогда навигация по коду станет очень сложной, поэтому
каждую компоненту принято выносить в отдельный файл с таким же названием как и сама компонента

// 8 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Исходя из того, что каждый компонент имеет свой свобственный файл, эти файлы необходимо как-то связывать вместе. Соответственно теперь два компонента,
которые мы создавали в предыдущем уроке нам изначально необходимо вынести в отдельные файлы.

После вынесения в отдельные файлы всех компонентов, нам необходимо ими обмениваться. Для этого и существует import и export
Синтаксис следующий:

import lalala from 'path' 

lalala - название какой-то компоненты, которую мы будем использовать в данном коде
'path' - относительный путь (не абсолютный)
Относительный путь задается относительно того файлы в который мы импортируем. То есть находясь в файле App.js я задаю относительный путь для поиска
от данного файла. Чтобы остаться в этой же папке "./" для того чтобы выйти в родительскую "../"

export default lalala

lalala - название компонента (функции) который мы экспортируем из этого файла при необходимости импортировать где-то в другом месте.
(Для того чтобы файл понималь когда из него что-то хотят импортировать, что именно он должен отдать)

Для SomePart.js это - export default SomePart
Для Header.js это - export default Header

Соответственно теперь для подключения этих файлов в App.js необходимо их импортировать
import Header from './Header.js'
import SomePart from './SomePart.js'

// 10 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Когда мы импортируем какой-либо компонент мы задаем для него название после слова import. Соответственно есть шанс ошибиться и импортировать в 
переменную SomePart не компонент SomePart, а например, Header. Для того чтобы избежать такой ситуации мы должны задавать названия компонентам
строго в соответствии с их навзаниями в файлах из которых мы их экспортируем. 
Для того чтобы не использовать случайно компонент который забыли импортировать можно установить плагин "Auto import"

// 11 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Grid-верстка
grid-template-rows: 1fr 1fr;  -  задаем количество строк и их пропорциональное отношение (fr - фракция)
grid-template-columns: 1fr 5fr; задаем количество столбцов и их пропорциональное отношение (fr - фракция)

Каждому элементу который будем позиционировать относительно данной разметки необходимо задать собственное имя для grid разметки в css
.nav {
    grid-area: nav;
}
.content {
    grid-area: cont;
}
.header {
    grid-area: header;
}

После того как элементам дас помощью grid-area присвоено grid-название и создан шаблон таблицы с помощью grid-template-rows(columns)
необходимо расставить данные элементы в созданный шаблон с помощью grid-template-areas

.app-wrapper {
    display: grid;

    grid-template-rows: 60px 1fr;
    grid-template-columns: 1fr 5fr;

    grid-template-areas:
        'header header'
        'nav cont';
}

Шаблон из 4 ячеек 2х2 заполняется следующим образом:
                    1столбик   2столбик
    Первая строка - header     header
    Вторая строка - nav        cont

row-gap: 10px; - задает отступ между строк
column-gap: 10px; - задает отступ между столбцов

// 14 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке мы разбили общий файл с CSS свойствами на отдельные файлы (соответствующие компонентам) и подключили их к соответствующим компонентам. Такой подход кажется
удобным и функциональным т.к. у нас теперь нет огромного монолитного файла CSS-свойств, а есть отдельные файлы для описания свойств каждого отдельного компонента. 
Такой подход более читабельный и ускоряет навигацию между стилями. Однако есть одно существенное "но". Если мы зададим например классу 'item' свойства в файле Profile.jsx, 
то они применятся и к элементам с классом 'item' в других файлах, как например тут, к элементам файла Navigation.jsx

Подробно про этот процесс:
Если проинспектировать страницу проекта, то во вкладке Network можно заметить, что в браузер не приходит ни одного CSS файла. Т.к. все компоненты и стили к ним приходят 
одним монолитным JS-файлом под названием "bundle.js". Из этого файла все CSS стили вставляются в сам HTML-документ в тегах <style></style> в шапке страницы 
(в теге <head></head>) и там уже все эти стили имеют одинаковый уровень вложенности, а соответственно переназначают стили элементам с одинаковым названием селекторов. 
(Каждый одельный CSS файл для компонента - отдельный тег <style></style> и из этого следует, что стили будут переназначать по последнему добавленному файлу стилей 
компонента. Например, если у нас в header и в footer есть тег <nav></nav> и ему заданы свойства в CSS файлах соответствующих компонентов, то к nav внутри header применятся 
свойства nav в footer, т.к. тег <style></style> для footer добавится после тега <style></style> для header в <head></head> страницы) 

Для того чтобы избежать перетерания стилей необходимо в jsx файлы компонентов импортировать не просто .css файл, а module.css файл. Т.е. название файла navigation.css
нам необходимо переназначить на navigation.module.css. Теперь этот файл возращает объект со стилями и соответственно при импорте из этого файла мы должны обработать, 
возвращаемый объект каким-то образом.
Данный файл добавляет каждому селектору в соответствующем файле префикс и постфикс (которые означают имя компонента и уникалльный идентификатор который гарантированно
не будет повторяться в проекте). Т.е. .nav превращается в .Navigation_nav__1QeRT5

Navigation - название компонента
1QeRT5 - уникальный id

Соответственно, чтобы обработать и присвоить переписанные классы нам нужно обратиться к импортирорванному объекту который представлен в формате:
{
    'item': 'Navigation_item_qW34Sr',
    'nav': 'Navigation_nav__1QeRT5'
}
Соотвтественно для правильной обработки данного файла и правильного присваивания классов мы должны сделать следующее:
1. Правильно импортировать CSS-модуль (import NavigationStyles from "./Navigation.module.css";)
2. Соответствующим className элементов задать значение ={NavigationStyles.item} или ={NavigationStyles['item']}

Стили лучше задавать через обращение с помощью квадратных скобок [], т.к. некоторые названия включают символ "-" который не распознаётся JS и поэтому свойство объекта
(название класса) лучше передавать как строку в квадратных скобках или вместо "-" использовать нижнее подчеркивание "_"

После реализации данного подхода свойства перестают перетираться, т.к. теперь в нашем примере для ".item a" внутри Navigation.jsx задан класс ".Navigation_item_qW34Sr a", 
а для ".item a" внутри Profile.jsx задан просто класс ".item a"
С таким подходом необязательно использовать методологию БЭМ.
Теперь осталось закоментировать все console.log() и в Profile.jsx убрать тег <a></a> созданный там для показательного примера перетерания стилей

Для того чтобы добавлять несколько классов можно использовать шаблонные строки (обратные кавычки). 
Синтаксис следующий: {`${module.class} ${module.anotherClass}`}
Сначала добавляем в JSX выражение на JS с помощью обратных кавычек, а затем внутри них через пробел перечисляем необходимые классы

// 15 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Компоненты и их CSS модули лучше компоновать в отдельные папки с названием папки как у самого компонента.

// 16 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Чтобы в обычном JS изменять поведение функции необходимо внутри её логики обрабатывать передаваемые параметры. Так же это работает и для ReactJS.
Для того чтобы обрабатывать те или иные изменяемые параметры (свойства) мы передаем в функцию-компонент объект содержащий в качестве свойств
весь необходимый набор параметров. Этот объект называется "props".
Когда мы вызываем компонент без каких-либо дополнительных записей (например, просто <Header />), в него передается пустой объект props
Так как компонент ReactJS - это тег, а теги мы настраиваем через атрибуты, то соответственно мы можем настроить и передать какие-то данные
извне в компонент (передать данные из компонента-родителя компоненту-дочке). Соответственно если мы передаем какой-либо атрибут в компонент, то 
он добавляется в объект props и имя свойства - название атрибута, а его значение - значение атрибута.
Т.е. если вызываем:
<Header /> --------------> Props = {}
<Header name="Egor" age="23" /> --------------> Props = {
                                                            name: "Egor",
                                                            age: "23"
                                                        }
Для того, чтобы использовать передаваемые значение параметров внутри самого компонента используем:
1. Для JSX {props.atributeName}
2. Просто внутри функции props.atributeName

// 18 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке вынесем grid разметку для компонента Profile.jsx в тег <main></main> внутри App.js для того чтобы постоянно при изменении содержания блока content (в grid)
не записывать каждому компоненту свойство grid-area: content; 
Данное свойство просто задано обертке для компонентов в ячейке content

// 19 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Изначально, конечно ссылкам необходимо задать URL адрес запроса с помощью тега href="". Важно, что когда мы задаем данные адрес мы указываем путь относительно папки проекта 
и не ставим точки в данном пути, т.к. уже работаем не с файловой системой, как например, при импорте компонентов в проекте, а работаем с созданием запросов REST API, а там
точки не ставятся. То есть задаем href="/profile" (Это значит что "/profile" добавится к изначальному URL адресу) - для ссылки ведущей к компоненту Profile и аналогично с 
другими ссылками и компонентами для них.

Помимо этого, для того чтобы отображение содержимого страницы зависило от URL к которому мы обращаемся по ссылке (тега <a></a>) необходимо установить дополнительный
пакет (модуль). Для этого необходимо в консоль написать команду "npm i react-router-dom". Однако если просто прописать команду и выполнить её, модуль установится, но
после выгрузки проекта в репозиторий данные о наличии этого пакета не сохраняться, т.к. папка node_modules не прикрепляется к проекту выгружаемому на репозиторий. Чтобы
добавить запись о данном модуле и о том, что он используется в проекте необходимо в конце команды дописать "-save" (также нужно делать для всех остальный устанавливаемых 
вручную пакетов). Соответственно, полная команда выглядит так "npm i react-router-dom -save".

После ввода команды, в файл package.json добавится новая запись раздел "dependencies" (зависимости): "react-router-dom": "^6.22.3". Теперь мы можем пользоваться данным 
пакетом. Для этого, в месте где будет происходить изменение компонентов (в нашем случае в компоненте App.js), нам необходимо импортировать компоненты Route и Routes из 
"react-router-dom". Вызвать компонент <Route /> для каждого из возможных вариантов компонентов, которые мы хотим отображать в зависимости от URL адреса по которому обращаемся,
предварительно выделив область для перечня возможных к отображению компонентов с помощью <Routes> </Routes>. 
Т.е.
1. import { Routes, Route } from "react-router-dom";
2. Создать область с помощью 
    <Routes> 
        ...тут перечислять <Route /> для каждого компонента которые мы хотим вызывать 
    </Routes>
3. Для всех компонентов которые могут отображаться в определенной области задать <Route element={название_компонента}/>
Однако если запустить код браузер выдаст ошибку "Cannot read properties of undefined (reading 'pathname')"
Ввиду того, что на данном этапе компонент <Route /> знает какие ей необходимо вызывать компоненты, но не знает при каком URL страницы это нужно делать. Компонент видит URL
и думает по умолчанию, что при любом URL нужно отображать соответствующий компонент (а значит в данном случае отобразятся все компоненты). Делает он это из-за отсутствия 
свойства (атрибута) "path". Значит компоненту <Route /> необходимо задать еще один атрибут под названием path равный тому относительному пути который мы задали ссылкам 
ведущим (отображающим) к соответствующему компоненту.

Однако даже после этого ничего не заработает, т.к. зона маршрутизации (весь компонент в котором она происходит) должен быть обернут в другой компонент под названием 
<BrowserRouter>, который тоже импортируется из пакета "react-router-dom". 
Т.е. конечная запись импорта выглядит так: 
import { Routes, Route, BrowserRouter } from "react-router-dom";

А конечный синтаксис для создания маршрутизации так: 

<BrowserRouter>
    <Routes>
        <Route />
        <Route />
        <Route />
        ... (количество возможных для вызова компонентов)
    </Routes>
</BrowserRouter>