// 51 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------

На данном этапе, нам необходимо избавиться от фиксированных (захардкоженых) пользователей, которых мы добавляем с помощью setUsers()
Для того, чтобы писать запросы на сервер, необходимо использовать библиотеку "axios", а следовательно, нам необходимо её установить с помощью команды "npm i axios --save"
и импортировать с помощью "import * as axios from "axios";" (запись "* as axios" означает, что мы хотим импортировать всё что имеет название axios внутри библиотке, как
"axios" в наш проект).
Непосредственно создание запросов мы реализуем внутри презентационной компоненты в блоке if(){}, который мы реализовали на прошлом уроке.

Любая серверная API (определенные endpoint'ы) имеют базовый URL-адрес, который не изменяется относительно типа выполняемого запроса (т.е. часть URL запроса всегда 
фиксирована и эта часть и называется "базовый URL")

Наш базовый URL: "https://social-network.samuraijs.com/api/1.0"

Если мы хотим обратиться за конкретными ресурсами (данными), то мы обращаемся к конкретному endpoint'у на сервер, например, users/. Таким образом, что получить данные с 
сервера мы знаем, что надо использовать GET-запрос к endpoint'у users/, предварительно в URL-адресе запроса указать базовый URL. Т.е. для того, чтобы создать запрос, нам
необходимо воспользоваться следующим синтаксисом:

axios.get("https://social-network.samuraijs.com/api/1.0/users")

Функция get("URL-адрес") содержит под капотом функционал выполнения запроса на сервер и оборачивания его в промис. Соответственно, результат вызова данной функции - промис
и для того, чтобы обработать содержащийся в этом промисе результат выполнения запроса, нам необходимо вызвать у данного промиса метод then(), который принимает в себя
в качестве параметра сам результат выполнения запроса (response).
Синтаксис:

axios.get("https://social-network.samuraijs.com/api/1.0/users").then( (response)=>{
    *обработка ответа сервера*
} )

Логично, что данный функционал мы должны поместить внутрь блока if(props.users.length === 0){...}, ввиду того, что первоначальную установку пользователей функцией 
setUsers() мы будем выполнять автоматически (без нажатия на кнопку "Show more")

По данному запросу мы получаем объект (response), который содержит в себе большое количество свойств, а именно:

config: {transitional: {…}, adapter: Array(2), transformRequest: Array(1), transformResponse: Array(1), timeout: 0, …}
data: {items: Array(10), totalCount: 26169, error: null}
headers: AxiosHeaders {cache-control: 'no-cache', content-length: '1260', content-type: 'application/json; charset=utf-8', expires: '-1', pragma: 'no-cache'}
request: XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …}
status: 200
statusText: ""

Это объект ответа сервера (впринципе данные характеризующие сам запрос) и для того, чтобы добраться до данных, сидящих внутри этого объекта, нам необходимо обратиться к 
полю "data" (данные с сервера, полученный по данному запросу с сервера)

data: {
    error: null,
    items: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}],
    totalCount: 26169,
}

Значит на данном моменте, необходимые объекты пользователей (для отображения на странице) находятся внутри response.data.items, а значит в методе then(), вызванном после
выполнения запроса, мы должны обработать ответ сервера и получить эти данные, а затем передать их в функцию setUsers(), т.е.:

if (props.users.length === 0) {
    axios.get("https://social-network.samuraijs.com/api/1.0/users").then((response) => {
        let users = response.data.items
        props.setUsers(users)
    })
}

Однако на данном моменте мы получим ошибку, ввиду того, что обрабатываем внутри презентационной компоненты свойства объекта пользователя, которых на самом деле у этих
объектов нет, например, "lcountry", "city" и др. Так происходит ввиду того, что полученный с сервера объекты имеют следующие поля:

{
    name: "Matuxa",
    id: 31161,
    uniqueUrlName: null,
    photos: {
        small: null,
        large: null
    },
    status: null,
    followed: false
}

А обработнные ранее объекты презентационной компоненты имели следующие:

{ 
    id: "1", 
    avatarURL: "https//worldpodium.ru/sites/default/files/styles/400x400sc/public/gosha_rubchinskiy.jpg?itok=q5UPHzac", 
    firstName: "Gosha", 
    secondName: "Rubchinskiy", 
    status: "I'm a big lover of potatoes", followed: true, 
    location: { 
        country: "Russia", 
        city: "Moscow" 
    }
}

Чтобы таких казусов не возникало на реалиных проектах, необходимо разрабатывать презентационные компоненты исходя из того формата данных, который разработан на сервере.
Т.е. изначально, нужно смотреть на то, какие объекты пользователя лежат на сервере и какие поля оин имеют, чтобы не создавать лишние ошибки и дополнительную работу себе
или бэкендеру. Исходя из этого, нам необходимо переписать функционал презентационной компоненты под текущие данные с сервера.

Для обработки аватарки пользователя, мы можем использовать функционал тернанрных выражений, чтобы в случае если у объекта пользователя нет собственной установленной 
фотографии мы возвращали фиксированную (серую) заглушку. Для этого, эту заглушку нужно добавить в папку проекта и импортировать внутрь презентационной компоненты. 
Соответственно, синтаксис будет следующим:

import BaseUserAvatar from "../../images/user_without_photo.jpg";
...
<img src={user.photos.small !== null ? (user.photos.small) : BaseUserAvatar} alt="Avatar" />

ВАЖНО:
В прошлом уроке мы допустили серьезную погрешность, т.к. выполняем запрос внутри презентационной компоненты, нарушая тем самым принцип чистых функций. Теперь при каждом
ререндере компоненты мы должны выполнять запрос на сервер (хоть мы и избежали этого поведения с помощью блока if(){...}, всё равно факт наличия дополнительного 
функционала непредусмотренного презентационной компонентой остается). Для того чтобы решить данную проблему, мы будем использовать классовые компоненты. Важно отметить, 
что сейчас данный вопрос решается с помощью хуков, но мы будем все равно использовать устаревшие классовые компоненты и постепенно придем к хукам (т.к. понимание хуков
строится на понимании классовых компонентов).