// 2 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
NodeJS - платформа для взаимодейтсвия с помощью JavaScript, например, с файловой системой, с серверной частью (с помощью NodeJS и создается программа для сервера) и т.д.

Node.js — программная платформа, основанная на движке V8 (компилирующем JavaScript в машинный код), превращающая JavaScript из узкоспециализированного языка в язык 
общего назначения. Node.js добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API, написанный на C++, подключать другие внешние 
библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода.

NodeJS содержит в себе несколько различных написанных программ (пакетов), которые устанавливаются с помощью рабочей лошидки NodeJS - NPM (nodejs packages manager)
Для запуска таких программ существует другая рабочаяя лошадка - NPX.

// 3 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Установка - https://nodejs.org/en/download

// 4 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Открываем консоль NodeJS (command prompt) и открываем папку в которой будем создавать наш проект
По умолчанию консоль открыта на диске C. Чтобы сменить диск необходимо написать имя диска и двоеточие "d:" и нажать Enter

Теперь чтобы перейти в необходимую нам директорию (сменить её) необходимо написать cd (change directory) и указать путь к папке (директории)
Чтобы поднять на уровень выше (выйти из папки) необходимо написать "cd ..", а чтобы провалиться "cd имя-папки/имя-внутренней-папки" и т.д.

После установик пакета запустить проект с помощью npm start не получится т.к. мы остались в предыдущей директории где лежит не сам проект (пакет)
а лишь папка с этим проектом, а значит нам необходимо провалиться в папку с проектом (там лежит package.json - набор настроек проекта, без которого
проект не запуститься)

// 5 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
JSX - это своегорода синтаксический сахар позволяющий писать HTML разметку внутри JavaScript кода
Один JavaScript файл (компонент) должен быть представлен либо функцией которая возвращает HTML разметку с помощью return с логикой внутри себя, 
либо класс с методом render(). Важно что родительский элемент должен быть только один (нельзя вернуть два и болле тега на первом уровне вложенности)


// 6 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
SPA - крутая концепция, т.к. позволяет не запращивать у сервера постоянно новый HTML документ при каждой перезагрузки страницы, а разово загрузить
страницу и отправлять с помощью большого количества JS подгруженного изначально AJAX-запросы серверу, в ответ на которые тот шлет JSON объекты с 
данными. Теперь если вам на странице с сообщениями (например в ВК) пришло новое сообщение, нет необходимости рендерить весь HTML документ заново.
Мы просто считываем данные с JSON (response) от сервера и отображаем их на странице. Таким образом SPA позволяет экономить ресурсы и компьютера и 
сервера одновременно.
Страница всегда одна даже если с раздела "Сообщения" необходимо перейти в раздел "Feed". Формально URL меняется, но запрашиваем мы не новый HTML,
а также данные JSON и просто заново отрисовываем первоначально загруженную страницу.

Также ввиду того, что на мобильной разработке приложений не используется HTML документы, мы не можем использовать обычный подход отправки страницы
целиком в браузере клиенту, т.к. этот сервер будет заточен под генерацию HTML, но когда мы используем в качестве обмена информацией JSON объекты,
то мы можем использовать один и тот же сервер и для мобильных приложений т.к. они способны отображать данные прочитанные из JSON

Картинка приложена к конспекту в папке 

// 7 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Компонент - это функция, возвращающая JSX разметку. Она может выполнять внутри себя логику и т.д. но обязательно должна вернуть JSX (содержание
которого может зависеть от логики внутри функции-компонента)

Компоненты можно вкладывать друг в друга, ведь они являются неким аналогом HTML-тега только уже в с вложенным контентом и другими тегами. Мы конечно
можем создать в одном файле App.js все компоненты сайта и объекдинить их в общую обертку, но тогда навигация по коду станет очень сложной, поэтому
каждую компоненту принято выносить в отдельный файл с таким же названием как и сама компонента

// 8 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Исходя из того, что каждый компонент имеет свой свобственный файл, эти файлы необходимо как-то связывать вместе. Соответственно теперь два компонента,
которые мы создавали в предыдущем уроке нам изначально необходимо вынести в отдельные файлы.

После вынесения в отдельные файлы всех компонентов, нам необходимо ими обмениваться. Для этого и существует import и export
Синтаксис следующий:

import lalala from 'path' 

lalala - название какой-то компоненты, которую мы будем использовать в данном коде
'path' - относительный путь (не абсолютный)
Относительный путь задается относительно того файлы в который мы импортируем. То есть находясь в файле App.js я задаю относительный путь для поиска
от данного файла. Чтобы остаться в этой же папке "./" для того чтобы выйти в родительскую "../"

export default lalala

lalala - название компонента (функции) который мы экспортируем из этого файла при необходимости импортировать где-то в другом месте.
(Для того чтобы файл понималь когда из него что-то хотят импортировать, что именно он должен отдать)

Для SomePart.js это - export default SomePart
Для Header.js это - export default Header

Соответственно теперь для подключения этих файлов в App.js необходимо их импортировать
import Header from './Header.js'
import SomePart from './SomePart.js'

// 10 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Когда мы импортируем какой-либо компонент мы задаем для него название после слова import. Соответственно есть шанс ошибиться и импортировать в 
переменную SomePart не компонент SomePart, а например, Header. Для того чтобы избежать такой ситуации мы должны задавать названия компонентам
строго в соответствии с их навзаниями в файлах из которых мы их экспортируем. 
Для того чтобы не использовать случайно компонент который забыли импортировать можно установить плагин "Auto import"

// 11 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Grid-верстка
grid-template-rows: 1fr 1fr;  -  задаем количество строк и их пропорциональное отношение (fr - фракция)
grid-template-columns: 1fr 5fr; задаем количество столбцов и их пропорциональное отношение (fr - фракция)

Каждому элементу который будем позиционировать относительно данной разметки необходимо задать собственное имя для grid разметки в css
.nav {
    grid-area: nav;
}
.content {
    grid-area: cont;
}
.header {
    grid-area: header;
}

После того как элементам дас помощью grid-area присвоено grid-название и создан шаблон таблицы с помощью grid-template-rows(columns)
необходимо расставить данные элементы в созданный шаблон с помощью grid-template-areas

.app-wrapper {
    display: grid;

    grid-template-rows: 60px 1fr;
    grid-template-columns: 1fr 5fr;

    grid-template-areas:
        'header header'
        'nav cont';
}

Шаблон из 4 ячеек 2х2 заполняется следующим образом:
                    1столбик   2столбик
    Первая строка - header     header
    Вторая строка - nav        cont

row-gap: 10px; - задает отступ между строк
column-gap: 10px; - задает отступ между столбцов

// 14 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке мы разбили общий файл с CSS свойствами на отдельные файлы (соответствующие компонентам) и подключили их к соответствующим компонентам. Такой подход кажется
удобным и функциональным т.к. у нас теперь нет огромного монолитного файла CSS-свойств, а есть отдельные файлы для описания свойств каждого отдельного компонента. 
Такой подход более читабельный и ускоряет навигацию между стилями. Однако есть одно существенное "но". Если мы зададим например классу 'item' свойства в файле Profile.jsx, 
то они применятся и к элементам с классом 'item' в других файлах, как например тут, к элементам файла Navigation.jsx

Подробно про этот процесс:
Если проинспектировать страницу проекта, то во вкладке Network можно заметить, что в браузер не приходит ни одного CSS файла. Т.к. все компоненты и стили к ним приходят 
одним монолитным JS-файлом под названием "bundle.js". Из этого файла все CSS стили вставляются в сам HTML-документ в тегах <style></style> в шапке страницы 
(в теге <head></head>) и там уже все эти стили имеют одинаковый уровень вложенности, а соответственно переназначают стили элементам с одинаковым названием селекторов. 
(Каждый одельный CSS файл для компонента - отдельный тег <style></style> и из этого следует, что стили будут переназначать по последнему добавленному файлу стилей 
компонента. Например, если у нас в header и в footer есть тег <nav></nav> и ему заданы свойства в CSS файлах соответствующих компонентов, то к nav внутри header применятся 
свойства nav в footer, т.к. тег <style></style> для footer добавится после тега <style></style> для header в <head></head> страницы) 

Для того чтобы избежать перетерания стилей необходимо в jsx файлы компонентов импортировать не просто .css файл, а module.css файл. Т.е. название файла navigation.css
нам необходимо переназначить на navigation.module.css. Теперь этот файл возращает объект со стилями и соответственно при импорте из этого файла мы должны обработать, 
возвращаемый объект каким-то образом.
Данный файл добавляет каждому селектору в соответствующем файле префикс и постфикс (которые означают имя компонента и уникалльный идентификатор который гарантированно
не будет повторяться в проекте). Т.е. .nav превращается в .Navigation_nav__1QeRT5

Navigation - название компонента
1QeRT5 - уникальный id

Соответственно, чтобы обработать и присвоить переписанные классы нам нужно обратиться к импортирорванному объекту который представлен в формате:
{
    'item': 'Navigation_item_qW34Sr',
    'nav': 'Navigation_nav__1QeRT5'
}
Соотвтественно для правильной обработки данного файла и правильного присваивания классов мы должны сделать следующее:
1. Правильно импортировать CSS-модуль (import NavigationStyles from "./Navigation.module.css";)
2. Соответствующим className элементов задать значение ={NavigationStyles.item} или ={NavigationStyles['item']}

Стили лучше задавать через обращение с помощью квадратных скобок [], т.к. некоторые названия включают символ "-" который не распознаётся JS и поэтому свойство объекта
(название класса) лучше передавать как строку в квадратных скобках или вместо "-" использовать нижнее подчеркивание "_"

После реализации данного подхода свойства перестают перетираться, т.к. теперь в нашем примере для ".item a" внутри Navigation.jsx задан класс ".Navigation_item_qW34Sr a", 
а для ".item a" внутри Profile.jsx задан просто класс ".item a"
С таким подходом необязательно использовать методологию БЭМ.
Теперь осталось закоментировать все console.log() и в Profile.jsx убрать тег <a></a> созданный там для показательного примера перетерания стилей

Для того чтобы добавлять несколько классов можно использовать шаблонные строки (обратные кавычки). 
Синтаксис следующий: {`${module.class} ${module.anotherClass}`}
Сначала добавляем в JSX выражение на JS с помощью обратных кавычек, а затем внутри них через пробел перечисляем необходимые классы

// 15 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Компоненты и их CSS модули лучше компоновать в отдельные папки с названием папки как у самого компонента.

// 16 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Чтобы в обычном JS изменять поведение функции необходимо внутри её логики обрабатывать передаваемые параметры. Так же это работает и для ReactJS.
Для того чтобы обрабатывать те или иные изменяемые параметры (свойства) мы передаем в функцию-компонент объект содержащий в качестве свойств
весь необходимый набор параметров. Этот объект называется "props".
Когда мы вызываем компонент без каких-либо дополнительных записей (например, просто <Header />), в него передается пустой объект props
Так как компонент ReactJS - это тег, а теги мы настраиваем через атрибуты, то соответственно мы можем настроить и передать какие-то данные
извне в компонент (передать данные из компонента-родителя компоненту-дочке). Соответственно если мы передаем какой-либо атрибут в компонент, то 
он добавляется в объект props и имя свойства - название атрибута, а его значение - значение атрибута.
Т.е. если вызываем:
<Header /> --------------> Props = {}
<Header name="Egor" age="23" /> --------------> Props = {
                                                            name: "Egor",
                                                            age: "23"
                                                        }
Для того, чтобы использовать передаваемые значение параметров внутри самого компонента используем:
1. Для JSX {props.atributeName}
2. Просто внутри функции props.atributeName

// 18 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке вынесем grid разметку для компонента Profile.jsx в тег <main></main> внутри App.js для того чтобы постоянно при изменении содержания блока content (в grid)
не записывать каждому компоненту свойство grid-area: content; 
Данное свойство просто задано обертке для компонентов в ячейке content

// 19 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Изначально, конечно ссылкам необходимо задать URL адрес запроса с помощью тега href="". Важно, что когда мы задаем данные адрес мы указываем путь относительно папки проекта 
и не ставим точки в данном пути, т.к. уже работаем не с файловой системой, как например, при импорте компонентов в проекте, а работаем с созданием запросов REST API, а там
точки не ставятся. То есть задаем href="/profile" (Это значит что "/profile" добавится к изначальному URL адресу) - для ссылки ведущей к компоненту Profile и аналогично с 
другими ссылками и компонентами для них.

Помимо этого, для того чтобы отображение содержимого страницы зависило от URL к которому мы обращаемся по ссылке (тега <a></a>) необходимо установить дополнительный
пакет (модуль). Для этого необходимо в консоль написать команду "npm i react-router-dom". Однако если просто прописать команду и выполнить её, модуль установится, но
после выгрузки проекта в репозиторий данные о наличии этого пакета не сохраняться, т.к. папка node_modules не прикрепляется к проекту выгружаемому на репозиторий. Чтобы
добавить запись о данном модуле и о том, что он используется в проекте необходимо в конце команды дописать "-save" (также нужно делать для всех остальный устанавливаемых 
вручную пакетов). Соответственно, полная команда выглядит так "npm i react-router-dom -save".

После ввода команды, в файл package.json добавится новая запись раздел "dependencies" (зависимости): "react-router-dom": "^6.22.3". Теперь мы можем пользоваться данным 
пакетом. Для этого, в месте где будет происходить изменение компонентов (в нашем случае в компоненте App.js), нам необходимо импортировать компоненты Route и Routes из 
"react-router-dom". Вызвать компонент <Route /> для каждого из возможных вариантов компонентов, которые мы хотим отображать в зависимости от URL адреса по которому обращаемся,
предварительно выделив область для перечня возможных к отображению компонентов с помощью <Routes> </Routes>. 
Т.е.
1. import { Routes, Route } from "react-router-dom";
2. Создать область с помощью 
    <Routes> 
        ...тут перечислять <Route /> для каждого компонента которые мы хотим вызывать 
    </Routes>
3. Для всех компонентов которые могут отображаться в определенной области задать <Route element={название_компонента}/>
Однако если запустить код браузер выдаст ошибку "Cannot read properties of undefined (reading 'pathname')"
Ввиду того, что на данном этапе компонент <Route /> знает какие ей необходимо вызывать компоненты, но не знает при каком URL страницы это нужно делать. Компонент видит URL
и думает по умолчанию, что при любом URL нужно отображать соответствующий компонент (а значит в данном случае отобразятся все компоненты). Делает он это из-за отсутствия 
свойства (атрибута) "path". Значит компоненту <Route /> необходимо задать еще один атрибут под названием path равный тому относительному пути который мы задали ссылкам 
ведущим (отображающим) к соответствующему компоненту.

Однако даже после этого ничего не заработает, т.к. зона маршрутизации (весь компонент в котором она происходит) должен быть обернут в другой компонент под названием 
<BrowserRouter>, который тоже импортируется из пакета "react-router-dom". 
Т.е. конечная запись импорта выглядит так: 
import { Routes, Route, BrowserRouter } from "react-router-dom";

А конечный синтаксис для создания маршрутизации так: 

<BrowserRouter>
    <Routes>
        <Route />
        <Route />
        <Route />
        ... (количество возможных для вызова компонентов)
    </Routes>
</BrowserRouter>

// 20 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данном этапе настроенная маршрутизация с помощью ссылок (тегов <a></a>) перезагружает страницу полностью при каждом изменении URL. SPA так работать не должно. Оно должно
просто отрисовывать компонент из JS загруженного кода, но не перезагружать каждый раз страницу, т.к. та самая оптимизация SPA при таком подходе не работает и ReactJS 
применяется бессмысленно. Чтобы исправить такое поведение, нам нужно вместо тега <a></a> использоваться тег <NavLink></NavLink> и вместо атрибута href="" использовать
атрибут to="", значение которого также остается равным дописи к URL адресу (относительному корневой папки проекта пути без точек).
Собственно данный компонент <NavLink></NavLink> служит для того, чтобы задать певедение ссылке (тегу <a></a>) с исключением - он отменяет перезагрузку (preventDefault) 
ссылки. Т.к. <NavLink></NavLink> является компонентом его нужно импортировать как пакет из модуля "react-router-dom". Чтобы импортировать именно определенный пакет по
его названию (или несколько пакетов) нам необходимо заключить его имя в строке импорта в фигурные скобки как мы это делали ранее при импорте {BrowserRouter, Route, Routes}
Строка импорта: import { NavLink } from "react-router-dom";

NavLink под капотом задает последней кликнутой ссылке класс "active" (внутри HTML) для того чтобы мы могли определенным образом помечать текущую ссылку, например, другим
цветом. Важно, что добавленный с помощью NavLink класс "active" и заданный нами в CSS модуле класс "active" не будут равны, т.к. CSS модуль добавляет префиксы и постфиксы
для идентификации CSS стилей к каждому компоненту и избежания пересечения имён классов. Соответственно, NavLink в любой случае будет задавать простой класс "active" и он
не может знать какие префиксы и постфиксы будут у того "active" который мы раскрашиваем. Чтобы дать ему понять, что нужно добавлять не просто "active", а тот "active"
который лежит в объекте возвращаемом CSS модулем по ключу "active" нам необходимо задать следующий класс: 
className={ navData => navData.isActive ? NavigationStyles.active : NavigationStyles.link}

Что тут происходит?
1. NavLink возвращает определенные данные (navData) которые содержат всю информацию о данном атрибуте (активен или нет, какие URL и т.д.)
2. В фигурных скобках мы обрабатываем эти данные и в зависимости от значение поля isActive (true или false) реализуем ту или иную часть условного выражения (конструкция ? :)
3. По результатам этого условного выражения для простой (не активной) возвращаем класс для обычной ссылки, для активной ссылки возвращаем класс "active" из фигурных скобок
4. Данный класс вызывается из CSS модуля, а значит имеет необходимые постфиксы и префиксы и соответственно присваивается атрибуту className

Тем самым мы "говорим" NavLink'у "Дружище, не мог бы ты добавлять активным ссылкам не просто класс active, как ты это делаешь по умолчанию, а вот этот класс - 
NavigationStyles["active"]".

Ссылкам добавленным внутрь <li></li> необходимо задать display: block; чтобы они отображались относительно родительского <li></li>

Для самостоятельного изучения вне курса - "history API HTML5"

// 22 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для того чтобы на странице диалогов отображались чаты (список сообщений) в зависимости от выбранного пользователя, нам также как и раньеш необходимо использовать в качестве
элементов списка пользователей не простые ссылки, а <NavLink></NavLink>. Задавая им атрибут to="/2", возникает логичный вопрос: "Если по этому URL мы открываем конкретный чат,
а Route для компонента Dialogs ждет от нас именно путь "/dialogs", то при изменении URL на "/dialogs/2" не пропадет ли компонент Dialogs со страницы?"
Ответ: нет, т.к. URL адрес читается слева направо и отображается компоненты последовательно, т.е. в адресе "http://localhost:3000/dialogs/2" браузер понимает, что сначала
нужно отобразить Dialogs, а затем внутри него ещё какой-то компонент по относительному пути в уже отображенном Dialogs, т.к. маршрутизация осуществляется уже внутри него. 

Соответственно, все чаты (список пользователей с которым есть переписка) нужно обернуть следующим образов в тег <NavLink></NavLink>:
<NavLink to="/1" className={navData => navData.isActive ? DialogsStyles.activeChat : DialogsStyles.chat}>
    <p className={DialogsStyles["user_name"]}>Лиза</p>
</NavLink>

Для того чтобы нижеприведенная запись отображала компонент ТОЛЬКО в случае если путь равне данному, то необходимо ещё добавить атрибут exact.
<BrowserRouter>
    <Routes>
        <Route exact path="/dialogs" element={названиеКомпонента} />
    </Routes>
</BrowserRouter>

Теперь данный Route не будет отображать компонент Dialogs при URL "/dialogs/2" в поисковой строке.

Однако в данном случае для изменения содержания блока "messages_with_user" (правой части компонента Dialogs), получается нам для каждого пользователя нужно загружать новый 
компонент? Для пользователя Лиза ждать путь "/dialogs/1" и далее добавлять соответствующий <Route /> и так для каждого вручную? 
Ответ: нет, можно использовать один компонент с разным наполнением (контентом) в зависимости от URL, но прежде чем понять как это работает нужно вспомнить props

* Заметка не по теме
Конструкция ниже просто добавляет слушатель события изменения URL адреса в определенном месте, но никак не связана с навигационной панелью и ссылками

<BrowserRouter>
    <Routes>
        <Route exact path="/dialogs" element={названиеКомпонента} />
    </Routes>
</BrowserRouter>

Сами <NavLink></NavLink> изменяет URL и отображают ссылку выделенной, но тоже никак не связаны с уровнями приложения и конструкцией выше
Грубо говоря, если <BrowserRouter> => <Routes> => <Route /> находится в Idea (внутри Ideas, внутри IdeaZone и т.д.), а сама ссылка задающая путь для этой Route в header 
страницы, то всё будет работать. Двум этим конструкциям необязательно находится на одном уровне или в одном компоненте.
*

// 23 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке, создадим гибкую компоненту для чатов (из списка пользователей с которыми есть сообщения) с помощью props и также создадим гибкую компоненту для 
отображения сообщений (упростим/отрефакторим код)

// 24 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
BLL - business logic layer (инкапсулирует всю бизнес-логику, все необходимые вычисления, получает объекты из уровня доступа к данным и передает их на уровень 
представления, либо, наоборот, получает данные с уровня представления и передает их на уровень данных)

UI - user interface (отображает полученные данные, благодаря BLL и отрисовывает их, либо передает какие-то данные (или команды) уровню BLL)

Концепция UI - BLL предполагает постоянное разделение двух этих уровней, поэтому данные пользователей хранить в качестве атрибутов для компонентов не совсем правильно
и логично, а значит их нужно выносить в отдельные "хранилища" памяти, а обрабатывать уже с помощью шаблонных компонентов ReactJS (через props)

Поэтому зададим массив пользователей и отобразим их пока что тоже в ручную без использования методов массивов
let usersForChats = [
    { id: 1, name: "Лиза", age: 23 },
    { id: 2, name: "Юля", age: 46 },
    { id: 3, name: "Андрей", age: 49 },
    { id: 4, name: "Никита", age: 22 },
    { id: 5, name: "Борис", age: 69 },
    { id: 6, name: "Наталья", age: 67 },
]
И отобразим таким образом: 
<DialogItem name={usersForChats[0].name} id={usersForChats[0].id} />

Ту же процедуру необходимо проделать с сообщениями и постами (т.е. со всеми сущностями нашего проекта)
Микро-спойлер:
BLL = Redux
UI - ReactJS

На данном этапе существует одна проблема: мы не знаем какого размера массив данных у нас будет, и поэтому ручное создание компонентов отображающих сущности неэффективно,
поэтому нужно использовать методы перебора массивов (объектов и т.д.), этому и будет посвящен следующий урок

// 25 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для динамического отображения данных в компоненте используем метод массивов map()
Создадим логику отображения компонента с данными сущности для каждой сущности массива данных, для постов (идей), сообщений и пользователей (чатов)

// 26 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Вынесем в отдельные компоненты <Message /> и <DialogItem /> из <Dialogs />.

UI (в нашем случае ReactJS) - набор файлов, который отвечает за отрисовку данных, которые приходят не из сервера напрямую, а из дополнительной прослойки (мы не отправляем
запрос на получение данных в файлах User Interface - мы делаем это в файлах BLL)
BLL - набор файлов, функций и т.д. отвечающий за хранение данных (в связке с ReactJS в роли BLL выступает Redux)

Ввиду этой концепции (Single resposibility) данные должны находится отдельно от компонентов (в других файлах). Т.е. следующие массивы данных в <Dialogs /> должны быть вынесены:
let usersForChats = [
    { id: 1, name: "Лиза", age: 23 },
    { id: 2, name: "Юля", age: 46 },
    { id: 3, name: "Андрей", age: 49 },
    { id: 4, name: "Никита", age: 22 },
    { id: 5, name: "Борис", age: 69 },
    { id: 6, name: "Наталья", age: 67 },
]
let messagesData = [
    { id: 1, text: "How are you?" },
    { id: 2, text: "Let's go to learn ReactJS" },
    { id: 3, text: "Are you sure about this?" },
    { id: 4, text: "Not exactly" },
    { id: 5, text: "So let's go to the park" },
]
И данные из Ideas тоже:
let postIdeaData = [
    { id: 1, likesCount: 7, text: "I'm pooping" },
    { id: 1, likesCount: 21, text: "Why don't we create an app" },
    { id: 1, likesCount: 14, text: "How to create a react app?" },
    { id: 1, likesCount: 52, text: "This's terribly difficult" },
]

Ввиду того, что в нашем проекте все файлы кроме index.js являются компонентами, а index.js выступает в роле руководителя (менеджера), то данные из всех компонентов логично
вынести в него и оттуда передать по компонентам. Т.е. в нашем случае BLL будет представлен index.js (изображение с структурой проекта прикреплено в папке урока)

*
Для самостоятельного изучения вне курса "Принципы SOLID"
*