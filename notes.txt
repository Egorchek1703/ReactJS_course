// 2 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
NodeJS - платформа для взаимодейтсвия с помощью JavaScript, например, с файловой системой, с серверной частью (с помощью NodeJS и создается программа для сервера) и т.д.

Node.js — программная платформа, основанная на движке V8 (компилирующем JavaScript в машинный код), превращающая JavaScript из узкоспециализированного языка в язык 
общего назначения. Node.js добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API, написанный на C++, подключать другие внешние 
библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода.

NodeJS содержит в себе несколько различных написанных программ (пакетов), которые устанавливаются с помощью рабочей лошидки NodeJS - NPM (nodejs packages manager)
Для запуска таких программ существует другая рабочаяя лошадка - NPX.

// 3 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Установка - https://nodejs.org/en/download

// 4 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Открываем консоль NodeJS (command prompt) и открываем папку в которой будем создавать наш проект
По умолчанию консоль открыта на диске C. Чтобы сменить диск необходимо написать имя диска и двоеточие "d:" и нажать Enter

Теперь чтобы перейти в необходимую нам директорию (сменить её) необходимо написать cd (change directory) и указать путь к папке (директории)
Чтобы поднять на уровень выше (выйти из папки) необходимо написать "cd ..", а чтобы провалиться "cd имя-папки/имя-внутренней-папки" и т.д.

После установик пакета запустить проект с помощью npm start не получится т.к. мы остались в предыдущей директории где лежит не сам проект (пакет)
а лишь папка с этим проектом, а значит нам необходимо провалиться в папку с проектом (там лежит package.json - набор настроек проекта, без которого
проект не запуститься)

// 5 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
JSX - это своегорода синтаксический сахар позволяющий писать HTML разметку внутри JavaScript кода
Один JavaScript файл (компонент) должен быть представлен либо функцией которая возвращает HTML разметку с помощью return с логикой внутри себя, 
либо класс с методом render(). Важно что родительский элемент должен быть только один (нельзя вернуть два и болле тега на первом уровне вложенности)


// 6 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
SPA - крутая концепция, т.к. позволяет не запращивать у сервера постоянно новый HTML документ при каждой перезагрузки страницы, а разово загрузить
страницу и отправлять с помощью большого количества JS подгруженного изначально AJAX-запросы серверу, в ответ на которые тот шлет JSON объекты с 
данными. Теперь если вам на странице с сообщениями (например в ВК) пришло новое сообщение, нет необходимости рендерить весь HTML документ заново.
Мы просто считываем данные с JSON (response) от сервера и отображаем их на странице. Таким образом SPA позволяет экономить ресурсы и компьютера и 
сервера одновременно.
Страница всегда одна даже если с раздела "Сообщения" необходимо перейти в раздел "Feed". Формально URL меняется, но запрашиваем мы не новый HTML,
а также данные JSON и просто заново отрисовываем первоначально загруженную страницу.

Также ввиду того, что на мобильной разработке приложений не используется HTML документы, мы не можем использовать обычный подход отправки страницы
целиком в браузере клиенту, т.к. этот сервер будет заточен под генерацию HTML, но когда мы используем в качестве обмена информацией JSON объекты,
то мы можем использовать один и тот же сервер и для мобильных приложений т.к. они способны отображать данные прочитанные из JSON

Картинка приложена к конспекту в папке 

// 7 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Компонент - это функция, возвращающая JSX разметку. Она может выполнять внутри себя логику и т.д. но обязательно должна вернуть JSX (содержание
которого может зависеть от логики внутри функции-компонента)

Компоненты можно вкладывать друг в друга, ведь они являются неким аналогом HTML-тега только уже в с вложенным контентом и другими тегами. Мы конечно
можем создать в одном файле App.js все компоненты сайта и объекдинить их в общую обертку, но тогда навигация по коду станет очень сложной, поэтому
каждую компоненту принято выносить в отдельный файл с таким же названием как и сама компонента

// 8 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Исходя из того, что каждый компонент имеет свой свобственный файл, эти файлы необходимо как-то связывать вместе. Соответственно теперь два компонента,
которые мы создавали в предыдущем уроке нам изначально необходимо вынести в отдельные файлы.

После вынесения в отдельные файлы всех компонентов, нам необходимо ими обмениваться. Для этого и существует import и export
Синтаксис следующий:

import lalala from 'path' 

lalala - название какой-то компоненты, которую мы будем использовать в данном коде
'path' - относительный путь (не абсолютный)
Относительный путь задается относительно того файлы в который мы импортируем. То есть находясь в файле App.js я задаю относительный путь для поиска
от данного файла. Чтобы остаться в этой же папке "./" для того чтобы выйти в родительскую "../"

export default lalala

lalala - название компонента (функции) который мы экспортируем из этого файла при необходимости импортировать где-то в другом месте.
(Для того чтобы файл понималь когда из него что-то хотят импортировать, что именно он должен отдать)

Для SomePart.js это - export default SomePart
Для Header.js это - export default Header

Соответственно теперь для подключения этих файлов в App.js необходимо их импортировать
import Header from './Header.js'
import SomePart from './SomePart.js'

// 10 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Когда мы импортируем какой-либо компонент мы задаем для него название после слова import. Соответственно есть шанс ошибиться и импортировать в 
переменную SomePart не компонент SomePart, а например, Header. Для того чтобы избежать такой ситуации мы должны задавать названия компонентам
строго в соответствии с их навзаниями в файлах из которых мы их экспортируем. 
Для того чтобы не использовать случайно компонент который забыли импортировать можно установить плагин "Auto import"

// 11 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Grid-верстка
grid-template-rows: 1fr 1fr;  -  задаем количество строк и их пропорциональное отношение (fr - фракция)
grid-template-columns: 1fr 5fr; задаем количество столбцов и их пропорциональное отношение (fr - фракция)

Каждому элементу который будем позиционировать относительно данной разметки необходимо задать собственное имя для grid разметки в css
.nav {
    grid-area: nav;
}
.content {
    grid-area: cont;
}
.header {
    grid-area: header;
}

После того как элементам дас помощью grid-area присвоено grid-название и создан шаблон таблицы с помощью grid-template-rows(columns)
необходимо расставить данные элементы в созданный шаблон с помощью grid-template-areas

.app-wrapper {
    display: grid;

    grid-template-rows: 60px 1fr;
    grid-template-columns: 1fr 5fr;

    grid-template-areas:
        'header header'
        'nav cont';
}

Шаблон из 4 ячеек 2х2 заполняется следующим образом:
                    1столбик   2столбик
    Первая строка - header     header
    Вторая строка - nav        cont

row-gap: 10px; - задает отступ между строк
column-gap: 10px; - задает отступ между столбцов

// 14 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке мы разбили общий файл с CSS свойствами на отдельные файлы (соответствующие компонентам) и подключили их к соответствующим компонентам. Такой подход кажется
удобным и функциональным т.к. у нас теперь нет огромного монолитного файла CSS-свойств, а есть отдельные файлы для описания свойств каждого отдельного компонента. 
Такой подход более читабельный и ускоряет навигацию между стилями. Однако есть одно существенное "но". Если мы зададим например классу 'item' свойства в файле Profile.jsx, 
то они применятся и к элементам с классом 'item' в других файлах, как например тут, к элементам файла Navigation.jsx

Подробно про этот процесс:
Если проинспектировать страницу проекта, то во вкладке Network можно заметить, что в браузер не приходит ни одного CSS файла. Т.к. все компоненты и стили к ним приходят 
одним монолитным JS-файлом под названием "bundle.js". Из этого файла все CSS стили вставляются в сам HTML-документ в тегах <style></style> в шапке страницы 
(в теге <head></head>) и там уже все эти стили имеют одинаковый уровень вложенности, а соответственно переназначают стили элементам с одинаковым названием селекторов. 
(Каждый одельный CSS файл для компонента - отдельный тег <style></style> и из этого следует, что стили будут переназначать по последнему добавленному файлу стилей 
компонента. Например, если у нас в header и в footer есть тег <nav></nav> и ему заданы свойства в CSS файлах соответствующих компонентов, то к nav внутри header применятся 
свойства nav в footer, т.к. тег <style></style> для footer добавится после тега <style></style> для header в <head></head> страницы) 

Для того чтобы избежать перетерания стилей необходимо в jsx файлы компонентов импортировать не просто .css файл, а module.css файл. Т.е. название файла navigation.css
нам необходимо переназначить на navigation.module.css. Теперь этот файл возращает объект со стилями и соответственно при импорте из этого файла мы должны обработать, 
возвращаемый объект каким-то образом.
Данный файл добавляет каждому селектору в соответствующем файле префикс и постфикс (которые означают имя компонента и уникалльный идентификатор который гарантированно
не будет повторяться в проекте). Т.е. .nav превращается в .Navigation_nav__1QeRT5

Navigation - название компонента
1QeRT5 - уникальный id

Соответственно, чтобы обработать и присвоить переписанные классы нам нужно обратиться к импортирорванному объекту который представлен в формате:
{
    'item': 'Navigation_item_qW34Sr',
    'nav': 'Navigation_nav__1QeRT5'
}
Соотвтественно для правильной обработки данного файла и правильного присваивания классов мы должны сделать следующее:
1. Правильно импортировать CSS-модуль (import NavigationStyles from "./Navigation.module.css";)
2. Соответствующим className элементов задать значение ={NavigationStyles.item} или ={NavigationStyles['item']}

Стили лучше задавать через обращение с помощью квадратных скобок [], т.к. некоторые названия включают символ "-" который не распознаётся JS и поэтому свойство объекта
(название класса) лучше передавать как строку в квадратных скобках или вместо "-" использовать нижнее подчеркивание "_"

После реализации данного подхода свойства перестают перетираться, т.к. теперь в нашем примере для ".item a" внутри Navigation.jsx задан класс ".Navigation_item_qW34Sr a", 
а для ".item a" внутри Profile.jsx задан просто класс ".item a"
С таким подходом необязательно использовать методологию БЭМ.
Теперь осталось закоментировать все console.log() и в Profile.jsx убрать тег <a></a> созданный там для показательного примера перетерания стилей

Для того чтобы добавлять несколько классов можно использовать шаблонные строки (обратные кавычки). 
Синтаксис следующий: {`${module.class} ${module.anotherClass}`}
Сначала добавляем в JSX выражение на JS с помощью обратных кавычек, а затем внутри них через пробел перечисляем необходимые классы

// 15 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Компоненты и их CSS модули лучше компоновать в отдельные папки с названием папки как у самого компонента.

// 16 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Чтобы в обычном JS изменять поведение функции необходимо внутри её логики обрабатывать передаваемые параметры. Так же это работает и для ReactJS.
Для того чтобы обрабатывать те или иные изменяемые параметры (свойства) мы передаем в функцию-компонент объект содержащий в качестве свойств
весь необходимый набор параметров. Этот объект называется "props".
Когда мы вызываем компонент без каких-либо дополнительных записей (например, просто <Header />), в него передается пустой объект props
Так как компонент ReactJS - это тег, а теги мы настраиваем через атрибуты, то соответственно мы можем настроить и передать какие-то данные
извне в компонент (передать данные из компонента-родителя компоненту-дочке). Соответственно если мы передаем какой-либо атрибут в компонент, то 
он добавляется в объект props и имя свойства - название атрибута, а его значение - значение атрибута.
Т.е. если вызываем:
<Header /> --------------> Props = {}
<Header name="Egor" age="23" /> --------------> Props = {
                                                            name: "Egor",
                                                            age: "23"
                                                        }
Для того, чтобы использовать передаваемые значение параметров внутри самого компонента используем:
1. Для JSX {props.atributeName}
2. Просто внутри функции props.atributeName

// 18 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке вынесем grid разметку для компонента Profile.jsx в тег <main></main> внутри App.js для того чтобы постоянно при изменении содержания блока content (в grid)
не записывать каждому компоненту свойство grid-area: content; 
Данное свойство просто задано обертке для компонентов в ячейке content

// 19 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Изначально, конечно ссылкам необходимо задать URL адрес запроса с помощью тега href="". Важно, что когда мы задаем данные адрес мы указываем путь относительно папки проекта 
и не ставим точки в данном пути, т.к. уже работаем не с файловой системой, как например, при импорте компонентов в проекте, а работаем с созданием запросов REST API, а там
точки не ставятся. То есть задаем href="/profile" (Это значит что "/profile" добавится к изначальному URL адресу) - для ссылки ведущей к компоненту Profile и аналогично с 
другими ссылками и компонентами для них.

Помимо этого, для того чтобы отображение содержимого страницы зависило от URL к которому мы обращаемся по ссылке (тега <a></a>) необходимо установить дополнительный
пакет (модуль). Для этого необходимо в консоль написать команду "npm i react-router-dom". Однако если просто прописать команду и выполнить её, модуль установится, но
после выгрузки проекта в репозиторий данные о наличии этого пакета не сохраняться, т.к. папка node_modules не прикрепляется к проекту выгружаемому на репозиторий. Чтобы
добавить запись о данном модуле и о том, что он используется в проекте необходимо в конце команды дописать "--save" (также нужно делать для всех остальный устанавливаемых 
вручную пакетов). Соответственно, полная команда выглядит так "npm i react-router-dom --save".

После ввода команды, в файл package.json добавится новая запись раздел "dependencies" (зависимости): "react-router-dom": "^6.22.3". Теперь мы можем пользоваться данным 
пакетом. Для этого, в месте где будет происходить изменение компонентов (в нашем случае в компоненте App.js), нам необходимо импортировать компоненты Route и Routes из 
"react-router-dom". Вызвать компонент <Route /> для каждого из возможных вариантов компонентов, которые мы хотим отображать в зависимости от URL адреса по которому обращаемся,
предварительно выделив область для перечня возможных к отображению компонентов с помощью <Routes> </Routes>. 
Т.е.
1. import { Routes, Route } from "react-router-dom";
2. Создать область с помощью 
    <Routes> 
        ...тут перечислять <Route /> для каждого компонента которые мы хотим вызывать 
    </Routes>
3. Для всех компонентов которые могут отображаться в определенной области задать <Route element={название_компонента}/>
Однако если запустить код браузер выдаст ошибку "Cannot read properties of undefined (reading 'pathname')"
Ввиду того, что на данном этапе компонент <Route /> знает какие ей необходимо вызывать компоненты, но не знает при каком URL страницы это нужно делать. Компонент видит URL
и думает по умолчанию, что при любом URL нужно отображать соответствующий компонент (а значит в данном случае отобразятся все компоненты). Делает он это из-за отсутствия 
свойства (атрибута) "path". Значит компоненту <Route /> необходимо задать еще один атрибут под названием path равный тому относительному пути который мы задали ссылкам 
ведущим (отображающим) к соответствующему компоненту.

Однако даже после этого ничего не заработает, т.к. зона маршрутизации (весь компонент в котором она происходит) должен быть обернут в другой компонент под названием 
<BrowserRouter>, который тоже импортируется из пакета "react-router-dom". 
Т.е. конечная запись импорта выглядит так: 
import { Routes, Route, BrowserRouter } from "react-router-dom";

А конечный синтаксис для создания маршрутизации так: 

<BrowserRouter>
    <Routes>
        <Route />
        <Route />
        <Route />
        ... (количество возможных для вызова компонентов)
    </Routes>
</BrowserRouter>

// 20 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данном этапе настроенная маршрутизация с помощью ссылок (тегов <a></a>) перезагружает страницу полностью при каждом изменении URL. SPA так работать не должно. Оно должно
просто отрисовывать компонент из JS загруженного кода, но не перезагружать каждый раз страницу, т.к. та самая оптимизация SPA при таком подходе не работает и ReactJS 
применяется бессмысленно. Чтобы исправить такое поведение, нам нужно вместо тега <a></a> использоваться тег <NavLink></NavLink> и вместо атрибута href="" использовать
атрибут to="", значение которого также остается равным дописи к URL адресу (относительному корневой папки проекта пути без точек).
Собственно данный компонент <NavLink></NavLink> служит для того, чтобы задать певедение ссылке (тегу <a></a>) с исключением - он отменяет перезагрузку (preventDefault) 
ссылки. Т.к. <NavLink></NavLink> является компонентом его нужно импортировать как пакет из модуля "react-router-dom". Чтобы импортировать именно определенный пакет по
его названию (или несколько пакетов) нам необходимо заключить его имя в строке импорта в фигурные скобки как мы это делали ранее при импорте {BrowserRouter, Route, Routes}
Строка импорта: import { NavLink } from "react-router-dom";

NavLink под капотом задает последней кликнутой ссылке класс "active" (внутри HTML) для того чтобы мы могли определенным образом помечать текущую ссылку, например, другим
цветом. Важно, что добавленный с помощью NavLink класс "active" и заданный нами в CSS модуле класс "active" не будут равны, т.к. CSS модуль добавляет префиксы и постфиксы
для идентификации CSS стилей к каждому компоненту и избежания пересечения имён классов. Соответственно, NavLink в любой случае будет задавать простой класс "active" и он
не может знать какие префиксы и постфиксы будут у того "active" который мы раскрашиваем. Чтобы дать ему понять, что нужно добавлять не просто "active", а тот "active"
который лежит в объекте возвращаемом CSS модулем по ключу "active" нам необходимо задать следующий класс: 
className={ navData => navData.isActive ? NavigationStyles.active : NavigationStyles.link}

Что тут происходит?
1. NavLink возвращает определенные данные (navData) которые содержат всю информацию о данном атрибуте (активен или нет, какие URL и т.д.)
2. В фигурных скобках мы обрабатываем эти данные и в зависимости от значение поля isActive (true или false) реализуем ту или иную часть условного выражения (конструкция ? :)
3. По результатам этого условного выражения для простой (не активной) возвращаем класс для обычной ссылки, для активной ссылки возвращаем класс "active" из фигурных скобок
4. Данный класс вызывается из CSS модуля, а значит имеет необходимые постфиксы и префиксы и соответственно присваивается атрибуту className

Тем самым мы "говорим" NavLink'у "Дружище, не мог бы ты добавлять активным ссылкам не просто класс active, как ты это делаешь по умолчанию, а вот этот класс - 
NavigationStyles["active"]".

Ссылкам добавленным внутрь <li></li> необходимо задать display: block; чтобы они отображались относительно родительского <li></li>

Для самостоятельного изучения вне курса - "history API HTML5"

// 22 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для того чтобы на странице диалогов отображались чаты (список сообщений) в зависимости от выбранного пользователя, нам также как и раньеш необходимо использовать в качестве
элементов списка пользователей не простые ссылки, а <NavLink></NavLink>. Задавая им атрибут to="/2", возникает логичный вопрос: "Если по этому URL мы открываем конкретный чат,
а Route для компонента Dialogs ждет от нас именно путь "/dialogs", то при изменении URL на "/dialogs/2" не пропадет ли компонент Dialogs со страницы?"
Ответ: нет, т.к. URL адрес читается слева направо и отображается компоненты последовательно, т.е. в адресе "http://localhost:3000/dialogs/2" браузер понимает, что сначала
нужно отобразить Dialogs, а затем внутри него ещё какой-то компонент по относительному пути в уже отображенном Dialogs, т.к. маршрутизация осуществляется уже внутри него. 

Соответственно, все чаты (список пользователей с которым есть переписка) нужно обернуть следующим образов в тег <NavLink></NavLink>:
<NavLink to="/1" className={navData => navData.isActive ? DialogsStyles.activeChat : DialogsStyles.chat}>
    <p className={DialogsStyles["user_name"]}>Лиза</p>
</NavLink>

Для того чтобы нижеприведенная запись отображала компонент ТОЛЬКО в случае если путь равне данному, то необходимо ещё добавить атрибут exact.
<BrowserRouter>
    <Routes>
        <Route exact path="/dialogs" element={названиеКомпонента} />
    </Routes>
</BrowserRouter>

Теперь данный Route не будет отображать компонент Dialogs при URL "/dialogs/2" в поисковой строке.

Однако в данном случае для изменения содержания блока "messages_with_user" (правой части компонента Dialogs), получается нам для каждого пользователя нужно загружать новый 
компонент? Для пользователя Лиза ждать путь "/dialogs/1" и далее добавлять соответствующий <Route /> и так для каждого вручную? 
Ответ: нет, можно использовать один компонент с разным наполнением (контентом) в зависимости от URL, но прежде чем понять как это работает нужно вспомнить props

* Заметка не по теме
Конструкция ниже просто добавляет слушатель события изменения URL адреса в определенном месте, но никак не связана с навигационной панелью и ссылками

<BrowserRouter>
    <Routes>
        <Route exact path="/dialogs" element={названиеКомпонента} />
    </Routes>
</BrowserRouter>

Сами <NavLink></NavLink> изменяет URL и отображают ссылку выделенной, но тоже никак не связаны с уровнями приложения и конструкцией выше
Грубо говоря, если <BrowserRouter> => <Routes> => <Route /> находится в Idea (внутри Ideas, внутри IdeaZone и т.д.), а сама ссылка задающая путь для этой Route в header 
страницы, то всё будет работать. Двум этим конструкциям необязательно находится на одном уровне или в одном компоненте.
*

// 23 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке, создадим гибкую компоненту для чатов (из списка пользователей с которыми есть сообщения) с помощью props и также создадим гибкую компоненту для 
отображения сообщений (упростим/отрефакторим код)

// 24 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
BLL - business logic layer (инкапсулирует всю бизнес-логику, все необходимые вычисления, получает объекты из уровня доступа к данным и передает их на уровень 
представления, либо, наоборот, получает данные с уровня представления и передает их на уровень данных)

UI - user interface (отображает полученные данные, благодаря BLL и отрисовывает их, либо передает какие-то данные (или команды) уровню BLL)

Концепция UI - BLL предполагает постоянное разделение двух этих уровней, поэтому данные пользователей хранить в качестве атрибутов для компонентов не совсем правильно
и логично, а значит их нужно выносить в отдельные "хранилища" памяти, а обрабатывать уже с помощью шаблонных компонентов ReactJS (через props)

Поэтому зададим массив пользователей и отобразим их пока что тоже в ручную без использования методов массивов
let usersForChats = [
    { id: 1, name: "Лиза", age: 23 },
    { id: 2, name: "Юля", age: 46 },
    { id: 3, name: "Андрей", age: 49 },
    { id: 4, name: "Никита", age: 22 },
    { id: 5, name: "Борис", age: 69 },
    { id: 6, name: "Наталья", age: 67 },
]
И отобразим таким образом: 
<DialogItem name={usersForChats[0].name} id={usersForChats[0].id} />

Ту же процедуру необходимо проделать с сообщениями и постами (т.е. со всеми сущностями нашего проекта)
Микро-спойлер:
BLL = Redux
UI - ReactJS

На данном этапе существует одна проблема: мы не знаем какого размера массив данных у нас будет, и поэтому ручное создание компонентов отображающих сущности неэффективно,
поэтому нужно использовать методы перебора массивов (объектов и т.д.), этому и будет посвящен следующий урок

// 25 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для динамического отображения данных в компоненте используем метод массивов map()
Создадим логику отображения компонента с данными сущности для каждой сущности массива данных, для постов (идей), сообщений и пользователей (чатов)

// 26 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Вынесем в отдельные компоненты <Message /> и <DialogItem /> из <Dialogs />.

UI (в нашем случае ReactJS) - набор файлов, который отвечает за отрисовку данных, которые приходят не из сервера напрямую, а из дополнительной прослойки (мы не отправляем
запрос на получение данных в файлах User Interface - мы делаем это в файлах BLL)
BLL - набор файлов, функций и т.д. отвечающий за хранение данных (в связке с ReactJS в роли BLL выступает Redux)

Ввиду этой концепции (Single resposibility) данные должны находится отдельно от компонентов (в других файлах). Т.е. следующие массивы данных в <Dialogs /> должны быть вынесены:
let usersForChats = [
    { id: 1, name: "Лиза", age: 23 },
    { id: 2, name: "Юля", age: 46 },
    { id: 3, name: "Андрей", age: 49 },
    { id: 4, name: "Никита", age: 22 },
    { id: 5, name: "Борис", age: 69 },
    { id: 6, name: "Наталья", age: 67 },
]
let messagesData = [
    { id: 1, text: "How are you?" },
    { id: 2, text: "Let's go to learn ReactJS" },
    { id: 3, text: "Are you sure about this?" },
    { id: 4, text: "Not exactly" },
    { id: 5, text: "So let's go to the park" },
]
И данные из Ideas тоже:
let postIdeaData = [
    { id: 1, likesCount: 7, text: "I'm pooping" },
    { id: 1, likesCount: 21, text: "Why don't we create an app" },
    { id: 1, likesCount: 14, text: "How to create a react app?" },
    { id: 1, likesCount: 52, text: "This's terribly difficult" },
]

Ввиду того, что в нашем проекте все файлы кроме index.js являются компонентами, а index.js выступает в роле руководителя (менеджера), то данные из всех компонентов логично
вынести в него и оттуда передать по компонентам. Т.е. в нашем случае BLL будет представлен index.js (изображение с структурой проекта прикреплено в папке урока)

*
Для самостоятельного изучения вне курса "Принципы SOLID"
*

// 27 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для того чтобы прокинуть props в компонент который отображается с помощью <Route path="/dialogs" element={<ComponentName />} />, достаточно просто передать данные props в 
компонент отображающийся благодаря этому <Route />, т.е. element={<ComponentName messageText={props.text}/>}. Всё достаточно логично, однако ввиду того что вместо атрибута
element раньше использовался component={<ComponentName />}, и такой подход был недоступен. Раньше использовали вместо component атрибут render, принимающий анонимную функцию,
которая в свою очередь возвращала компонент (а значит появилась возможность передать в этот компонент props), т.к. он не напрямую находится в Route. Теперь же с обновлением
"react-router-dom" версии 6 component и render как бы объединили в одно атрибут element (свойство)

// 28 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данном этапе, у нас в файле index.js содержаться и данные и отображение UI, что противоречит концепции Single Resposibility, а значит данные необходимо переместить в 
другой файл. Для этого создадим папку Redux на одном уровне с Components и поместим в нее наш файл с данными, обернутыми в объект под названием state, где свойства 
объекта - это названия массивов данных, а значения - сами массивы. Данные оборачиваем в объект для того чтобы экспортировать из файла с данными только лишь один объект, 
а не все переменные которые мы бы имели с соответствующими массивами (грубо говоря оборачиваем всю кучу в мешок)
После импортирования файла state.js (который экспортирует сам объект обертку), его необходимо передать в компонент App.js через props. В данном случае, мы не делим данные
как делали это раньше, а передаем общий объект со всеми данными. После данного шага, при дальнейшей транспортировки данных необходимо надпись props.messages заменить на 
props.state.messages (state - это название объекта props который мы передаем в App.js). 
На данный момент концепция Redux как раз такая, какая сейчас у нас, т.е. все данные проекта хранятся в одном файле state.js и из него уже передаются в UI. И в ситуациях
когда мы имеем большой проект и огромное количество данных, нам не хочется иметь их все на одном уровне вложенности без какой-либо группировки. Для того чтобы избежать
беспорядка в данных мы можем их структурировать, объединяя блоки данных в объекты внутри объекта state (группируя), с условием того, что эти блоки будут иметь аналогичное 
название (или соотвествующее) с компонентами в которых они используются. Т.е. в объекте state создаем два новых объекта profilePage и dialogsPage в которые и помещаем данные
которыем используются соответственно в <Profile /> и <Dialogs />. Важно отметить, что мы создаем нвоые объекты для группировки как свойства глобального объекта state (а их
значения - это объект содержащий в себе в качестве свойств названия массиво и в качесвте значений сами массивы).
Т.е.
let state = {
    // Данные для Dialogs
    dialogsPage: {
        usersForChats: [
            { id: 1, name: "Лиза", age: 23 },
            { id: 2, name: "Юля", age: 46 },
            { id: 3, name: "Андрей", age: 49 },
            { id: 4, name: "Никита", age: 22 },
            { id: 5, name: "Борис", age: 69 },
            { id: 6, name: "Наталья", age: 67 },
        ],
        messagesData: [
            { id: 1, text: "How are you?" },
            { id: 2, text: "Let's go to learn ReactJS" },
            { id: 3, text: "Are you sure about this?" },
            { id: 4, text: "Not exactly" },
            { id: 5, text: "So let's go to the park" },
        ],
    },

    // Данные для Profile -> Ideas
    profilePage: {
        postIdeaData: [
            { id: 1, likesCount: 7, text: "I'm pooping" },
            { id: 1, likesCount: 21, text: "Why don't we create an app" },
            { id: 1, likesCount: 14, text: "How to create a react app?" },
            { id: 1, likesCount: 52, text: "This's terribly difficult" },
        ],
    }
}

Подобъекты - являются ветками, обслуживающими отдельные страницы.
Теперь остается зарефакторить использование этих данных при передачи их в компоненты с помощью props.

Мы должны использовать чистые функции (компоненты), а это значит, что мы недолжны передавать в компонент (функцию) любые данные с которыми данная функция не работает.
Также можно передавать в дочерние компоненты локальные props с названием state. Например, в Route внутри App.js:
<Route
    path="/profile" element={<Profile state={props.state.profilePage} />}
/>
для того, чтобы в самом Profile вызывать не props.postIdeaData, а props.state.postIdeaData
Это удобно, т.к. если в рамках одного Route нам нужно передать дважды (или более) данные для его дочерних компонентов, то мы просто передаем ему все данные которые 
используются в рамках этого компонента, а уже внутри него их сортируем. 
Т.е. вместо 
<Route path="/dialogs" element={<Dialogs messagesData={props.state.dialogsPage.messagesData} usersForChats={props.state.dialogsPage.usersForChats}/>}
мы просто передаем сам объект обертку для компонента <Dialogs />
<Route path="/dialogs" element={<Dialogs state={props.state.dialogsPage}/>} 
и уже внутри самого компонента разбиваем полученный локальный state на:
{props.state.messagesData} и {props.state.usersForChats}

*
Заметка не по теме:
Для того чтобы наладить routing в нашем проекте, нам не нужно оборачивать каждый навигационный блок в компонент <BrowserRouter></BrowserRouter>, а достаточно обернуть 
все содержимое сайта в файле index.js. При это необходимость оборачивать блоки навигации в <Routes></Routes> остается.

✅ Домашнее задание: добавить раздел друзей в sidebar и добавить аватарки для сообщений в чатах

// 31 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке мы начнем работать с динамикой, а именно, с изменением данных в нашем state.js благодаря определенным действиям произведенным в UI, а также научимся 
отлавливать данные действия пользователя и связывать их с данными (BLL). Основной ход событий идёт в файле Ideas.jsx 
Для того чтобы задать слушатель события какому-либо элементу в JSX необходимо в качестве атрибута задать onНазваниеСобытия={функция, выполоняющаяся при выполнении события}.
Т.е. синтаксис такой: <button onClick={ () => alert("Вы кликнули") }>Кликай тут</button>

Значением данного атрибута всегда должна быть callback функция (функция, которую мы передаем чтобы ее кто-то вызвал, а не вызываем сами). Внутри данной callback функции 
может находится большое количество строк кода и для того чтобы не раздувать разметку и делать код менее читаемым, функцию которую мы передаем в качестве значения аргумента
слушателя события лучше задать не внутри JSX, а просто внутри самого компонента. Обозначит функцию и после вызвать её.

Внутри функции, которая будет вызываться при реализации события, нам нельзя использовать document.getElementById и подобные конструции, т.к. данные конструкции взаимодействуют
напрямую с DOM-деревом, а ReactJS устроен таким образом, что сам забирает на себя вопросы взаимодействия с DOM-деревом и оптмизированно это всё делает. Для этого в React'е 
реализована концепция VirtualDOM.

Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется 
с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.
Соответственно мы не имеем право вмешиваться в работу ReactJS, что и означает, что использовать конструкции работающие с DOM деревом напрямую, нельзя.
(Одна из причин такого поведения заключается в том, что мы не знаем в конкретный момент времени отрисовано ли DOM-дерево на странице, т.е. мы взаимодействуем с каким-то 
элементом, но при это не уверены, находится ли он в момент взаимодействия в DOM-дереве, поэтому лучше взаимодейтсвовать с VDOM чтобы исключить наличие ошибок. А сам VDOM за
нас после полноценной своей загрузки отображает данные в DOM-дерево и только после этого выполняет функционал (грубо говоря подготовительный этап с целью уменьшить риски))

Соответственно для того чтобы получить элемент из VDOM-дерева нам необходимо использовать какой-то синтаксис вместо document.querrySelector() и др. 
Для того чтобы получить элемент из JSX кода нам необходимо:
1. Создать переменную в которую будет помещена ссылка на конкретный элемент VDOM
let newPostTextarea =
2. Для того чтобы показать React'у что тут будет храниться ссылка на элемент VDOM значение этой переменной должно быть равно вызову метода CreateRef() у модуля React
let newPostTextarea = React.CreateRef()
3. Сам элемент привязать к данной ссылке с помощью создания у него атрибута ref={названиеПеременной} (в которой лежит пустая ссылка)
let newPostTextarea = React.createRef()
<textarea ref={newPostTextarea}></textarea>

Важно, что для того чтобы использовать методы модуля React его необходимо импортировать с помощью 
import React from "react";

Каждая ссылка, созданная с помощью let newPostTextarea = React.CreateRef() - является объектом, всего с одним свойством current, которое в свою очередь ссылается на 
нативный HTML элемент (судя по всему уже непосредственно на DOM элемент, но это нужно уточнить *уточнил, всё правильно - напрямую к элементу DOM дерева*), поэтому для 
того чтобы получить значение данной textarea нам нужно использовать следующий синтаксис:

let textFromTextarea = newPostTextarea.current.value
    Где:
    newPostTextarea = {current: someNodeFromDOM}
    newPostTextarea.current = someNodeFromDOM
    newPostTextarea.current.value = текстовое значение этого элементам

Но при таком подходе важно понимать что взаимодействие (изменение элемента) происходит напрямую в DOM, а не в VDOM и поэтому данный вопрос ещё будет объясняться в следующих
уроках.
Соответственно, теперь нам необходимо полученные изменения (как в нашем примере, созданный новый пост) поместить в state.js и поновой отрендерить весь проект с целью 
повторного прокидования props внутри UI части, т.к. просто поместить данные в state.js - не значит отобразить их сразу же (т.к. помещение данных в другой файл не перерисовывает
компоненты заново). Как это сделать - тема следующего урока.

✅ Домашнее задание: добавить в компоненте Dialogs <textarea></textarea> и реализовать всю ту же логику сохранения напечатанного текста. (Сделано в CreateMessage.jsx)

// 32 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данном этапе мы научились отслеживать и получать данные не обращаюсь напрямую к DOM дереву через document. и т.д., а значит теперь нам необходимо передать внесенные 
изменения в бизнес логику проекта, т.е. в BLL. Для этого необходимо при добавлении сообщения или профиля, например, изменять и дополнять данные в state.js
Ввиду того, что функция, изменяющая данные должна быть в одном файле с данными (в state.js) нам необходимо её реализовать соответственно в этом же файле.
Для того чтобы вызвать функцию из state.js (верхний уровень - BLL) нам нужно прокинуть её с помощью props в необходимый компонент (для этого нужно экспортировать её из
state.js НЕ по дефолту). Поэтому идём в state.js и создаем эту функцию (addPostIdea):

let addPostIdea = (textOfIdea) => {
    let newPostIdea = {
        id: 5,
        likesCount: 0,
        text: textOfIdea,
    }

    state.profilePage.postIdeaData.push(newPostIdea)
}

Для того чтобы созданную функцию экспортировать не по дефолту, в момент создания функции пишем "export let названиеФункции = и т.д.". Теперь, для того чтобы её импортировать,
нам необходимо заключить в фигурные скобки имя данной функции, чтобы было понятно, что именно мы ищем в данном файле (без фигурных скобок будет импортировано то, что 
экспортируется по дефолту). При данном подходе мы в файле ищем именно то название которое есть в экспортирующем файле, а не как в случае без фигурных скобок, просто задаем
собственной название для элемента, который экспортируется по дефолту. Чтобы импортировать данную функцию в index.js напишем там 
import {addPostIdea} from './redux/state'

Теперь по аналогии с state необходимо прокинуть данную функцию по цепочке в компонент <Ideas /> и вызвать в нужном месте (в функции для слушателя событий). Т.е. при реализации
события будет вызвана функция из state.js, которая работает с данными в данном файле. 
Однако стоит отметить что при реализации события несмотря на то что функция вызывается визуального сопровождения нет (пост не добавляется на стену), т.к. компоненты не 
рендерятся по новой, т.к. функция всего лишь добавляет элемент в массив постов, но не заставляет React перерисовать UI 
Важно понимать, что функция находящаяся в другом файле и вызывающаяся из определенного места в компоненте с переданными параметрами на самом деле все равно вызывается в том
файле в котором была инициализирована, однако такой подход позволяет передать параметры для этой функции, как в нашем случае, из UI в BLL уровень
Отсюда делаем вывод, что каждый раз при изменении BLL уровня UI должен перерисовываться (несмотря на то, что может казаться, что это неэффективно)
*Насколько я помню React использует алгоритм поиска отличий, а значит "под капотом" данный процесс все равно как-то да оптимизирован*
Как по новой перерисовать компонент (и немного концепции FLUX) станет известно в следующем уроке.

// 33 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Для того чтобы перерисовать (выполнить рендер) всё UI-приложение нам необходимо вызвать функционал index.js, а именно:
root.render(
    <BrowserRouter>
        <App state={state} addPostIdea={addPostIdea} />
    </BrowserRouter>
);
в определенный момент времени, когда мы изменяем данные в state.js
Обернуть данный функционал в функцию, выполнить её один раз для первоначального render'а и экспортировать её в state.js с целью последующего её вызова внутри функции 
addPostIdea() при изменении данных в state.js. 
Т.е. при срабатывании события, считанная из textarea строка, благодаря функции обработчика событий, записывается и попадает в addPostIdea(таСамаяСтрока) в качестве параметра, 
а затем по цепочке вверх данный параметр передается до момент инициализации функции addPostIdea() в файл state.js и вызывается там изменяя массив данных, а после 
перерисовывает всё приложения, опираясь на новые данные.

let renderEntireTree = () => {
    root.render(
    <BrowserRouter>
        <App state={state} addPostIdea={addPostIdea} />
    </BrowserRouter>
    );
}
renderEntireTree()

Однако у данного подхода есть существенный минус и поэтому так делать нельзя. При таком подходе создается циклическая зависимость, т.к. до этого из state.js мы экспортируем 
данные в index.js, а теперь наоборот пытаемся из index.js экспоритровать в state.js функцию renderEntireTree(). Для более наглядного понимания, схемы приложения приложены в 
папку проекта.

Чтобы избежать пересечения импортов и циклической зависимости нам необходимо добавить третьего игрока - render.js в наш проект, который и будет содержать в себе функцию 
renderEntireTree(). Соответственно, функционал index.js переносится практически полностью в render.js
render.js выполняет функционал создания функции рендера и экспортирует эту функцию (важно, что render.js не создает корень). 

Эту функцию нам нужно использовать дважды:
1. Внутри index.js для начального рендера компонентов
2. Внутри state.js для ререндера приложения при изменении бизнес логики функцией addPostIdea() или аналогичными

Соответственно экспортировав renderEntireTree в эти два места всё равно ничего работать не будет, т.к. теперь есть циклическая зависимость между 
render.js передает renderEntireTree() ---> state.js
state.js передает state ---> render.js 
(на самом деле всё будет работать, но быть не должно и это всё - говнокод)

Соответственно, удалить renderEntireTree() из файла state.js мы не можем, т.к. после этого не получится перерисовывать данные, а значит мы должны удалить наоборот state из 
render.js. Но теперь мы не передаем данные никуда и при этом файлу render.js нужен state чтобы перерисовать его и отобразить опираясь на данные!

💡Гениальное решение:
Функция работает с параметрами, а значит ввиду того, что в render.js мы не вызываем функцию renderEntireTree() нам необязательно рабоать именно с state - объектом
Мы можем задать поведение для тех, кто будет вызывать данную функцию renderEntireTree(), обработав при её инициализации работу с параметрами, и сказать, что если кто-то
вызывает эту функцию и передает в нее параметр, то это должен быть (мы ожидаем) объект state и соответственно теперь мы можем передать в index.js который никому ничего не 
экспортирует (имеется ввиду render.js и state.js) данные из этих файлов и вызвать функцию renderEntireTree() передав в нее в качестве параметра state - объект данных
В данном случае index.js выполняет собирающую функцию и реализует функцию renderEntireTree(state)

Значит при таком подходе функцию addPostIdea() тоже нужно вынести в index.js чтобы избежать пересечения
render.js передает renderEntireTree() ---> state.js
state.js передает addPostIdea() ---> render.js 

Для этого добавим ещё один параметр функции renderEntireTree()

Что мы сделали чтобы избежать циклических зависимостей более подробно:
1. Выделили функцию рендера в отдельный файл render.js 
2. Написали для этой функции как обрабатывать входящие параметры (чтобы не импортировать в render.js объект state, т.к. мы уже вынуждены импортировать функцию renderEntireTree
внутрь state.js (чтобы вызывать ее когда нужно ререндерить приложение после изменения данных от VIEW))
3. Файл index.js стал "собирательным" т.к. из него мы ничего не экспортируем, а просто единожды вызываем импортированную renderEntireTree() (в момент первоначальной 
загрузки страницы выполняется index.js единожды (в этом и заключается коцепция SPA, т.к. больше ничего мы не подгружаем)) и передаем в неё в качестве параметров объект 
state и функции изменения этого объекта.
Таким образом у нас получается некое подобие концепции FLUX (сриншот приложен в папку проекта)

В нашем случае:
action (сторонний не от VIEW) - первоначальная загрузка страницы
store - хранилище данных = state.js
dispatcher - функция, меняющая состояние хранилища (state.js) = addPostIdea()
action (от VIEW) - клик по кнопке "Добавить пост"

Полезная ссылка по FLUX + useReducer: https://www.youtube.com/watch?app=desktop&v=UQTT9IDctys&ab_channel=%D0%9F%D0%BE%D0%BB%D0%B8%D0%BD%D0%B0%D0%BF%D1%80%D0%BEFrontend%F0%9F%92%9C

Чтобы обнулить текст textarea для создания поста после публикации поста (идеи) нам необходимо

Важно понимать, что для того чтобы приложение работало не только в визульном формате, первоначальное действие при реализации события - это изменить данные в Redux, а отрисовать 
по новой UI-часть уже нужно на основе измененных данных (это реализуется функцией ререндера внутри функции изменяющей данные ( renderEntireTree() ))

FLUX - это концепция, а Redux - конкретная реализация этой концепции

// 34 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данной концепции UI должен меняться в ответ на изменение state и соответственно, когда мы пишем что-то, например, в textarea мы изменяем UI (т.к. совершаем action, 
однако на данном этапе он не вызывает ререндер, но тем не менее какое-то действие мы совершаем и изменяем UI т.к. теперь у нас есть какой-то текст в textarea). При этом
сам state никак не меняется, а следовательно, такое поведение противоречит концепциям FLUX, Single Resposibility и т.д. потому что компонента созданная для простой 
отрисовки занимается изменением UI, что по идее должно происходить только с помощью ререндера приложения во время изменения state
Соответственно, для того чтобы соблюдать концепцию при вводе в textarea какого-либо текста, изначально нужно не отрисовать на UI изменение, а произвести изменения значения 
в state (с помощью обработчика событий onChange и функции изменения необходимой части в state, отображающейся по умолчанию в textarea, т.е. newPostIdeaText: ""). 
При изменении state как мы знаем происходит ререндер, а значит нам приходят новые данные в UI и приложение ререндерится, а следовательно, перерисовывается. 
По итогу получается такой своего рода посимвольный ререндер приложения (но нужно отметить, что в реальности, благодаря тому что React использует алгоритм сравнения 
изменений полный ререндер не производится (под капотом React сравнивает предыдущее состояние и добавляет только изменения, при этом весь проект хоть и ререндерится 
номинально, благодаря нашей функции renderEntireTree(), которую мы вызываем на соответствующее поле в state (в данном случае newPostIdeaText), тем не менее полноценной 
перерисовки всего приложения не происходит из-за оптимизации React))

Для того чтобы реализовать данный подход нам необходимо создать в state.profilePage новое свойство newPostIdeaText с значением пустой строки и повесить на сам тег 
обработчик событий, который будет на каждое изменение текста в textarea, сначала вызывать функцию изменения newPostIdeaText внутри state, а та в свою очередь 
будет ререндерить UI и отрисовывать изменения (посимвольная отрисовка).

Теперь нужно:
1. Создать обработчик события onChange
2. Создать функцию изменения состояния свойства newPostIdeaText внутри state.js, принимающую в качестве параметра новый текст введенный в textarea и ререндерющую приложение
после изменение самого состояния newPostIdeaText
3. При реализации события обработчик должен вызывать функцию, которая считывает изменения в textarea с помощью React.createRef() + ref={}, и вызывает функцию изменения,
созданную в п.2 (предварительно импортированную по всей цепочки от state.js)
4. Важно, что теперь функция ререндера - renderEntireTree() должна уметь обрабатывать третий параметр т.е. передавать в <App /> помимо state (с набором данных для отрисовки),
addPostIdea() (добавляющую пост при клике на кнопку (обработчик вызывает ее при клике)) ещё и функцию updateNewPostIdea()
5. И соответственно все вызовы renderEntireTree() должны иметь 3 параметра (т.к. например если вызов addPostIdea() будет иметь только 2 предыдущих параметра которые были
нужны до реализации FLUX концепции (посимвольно), то при добавлении поста addPostIdea() вызовет renderEntireTree(state, addPostIdea) и соответственно функция 
updateNewPostIdea будет равна undefined из-за перерисовки вызванной этой renderEntireTree()) 

Теперь чтобы обнулить содержание textarea нам также необходимо взаимодействовать с UI через state, т.к. запись createPostTextarea.current.value = ""; теперь обнуляет текст
внутри textarea независимо от BLL, т.е. нарушает концепцию отрисовки UI только исходя из полученных из BLL данных. Теперь для того чтобы взаимодействоать с newPostIdeaText
внутри state для обнуления textarea достаточно после добавления поста вызваться функцию изменения состояния свойства newPostIdeaText, а именно - updateNewPostIdea() передав
в качестве параметра пустую строку

Для того чтобы всё работало надо не забыть добавить textarea атрибут value равный пришедшему из props свойству объекта state - newPostIdeaText. В противном случае при 
добавлении текса каждый символ будет приходить в state благодаря функции updateNewPostIdea(), но renderEntireTree() который она вызывает не будет перерисовывать содержание
textarea т.к. сама textarea независит никак от приходящих данных

На данном этапе нам нет необходимости вызывать функцию addPostIdea() и передавать в неё текст, полученный с textarea, т.к. актуальное содержимое этой textarea уже содержится 
в state в свойстве newPostIdeaText. Соответственно, теперь можно упрастить код и не считывать текст находящийся в textarea на момент нажатия кнопки "Post"

Соответственно, и обнуление содержимого textarea после добавления поста, мы можем теперь выполнить внутри state, после того как добавим объект с данными поста в массив объектов.
Это можно сделать внутри функции добавления поста просто перезаписав state.profilePage.newPostIdeaText = "";
*
При этом стоит отметить, что мы всё равно нарушаем концепцию функционального программирования т.к. обращаемся в функциях addPostIdea() и updateNewPostIdea() к глобальному 
объекту state (а по концепции функция должна работать лишь с тем, что приходит в неё).
*

✅ Домашнее задание: сделать ту же логику с созданием сообщений, что и с написанием поста

// 35 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
По какой-то непонятной на данный момент причине нужно обратно удалить файл render.js и перенести его логику в index.js. Соотвтественно опять возникает вопрос как получить в 
файле state.js функцию ререндера - renderEntireTree(), избежав циклической зависимости (т.к. мы в первую очередь вынуждены импортировать в index.js объект данных state и 
получается при экспорте из index.js функции renderEntireTree() мы не можем импортировать из state сами данные).

Ранее мы уже пользовались этим методом:
У нас должа была быть циклическая зависимость:
App.js ------<App />------> index.js (чтобы вызвать этот компонент в index.js)
index.js -------addPostIdea(),updateNewPostIdea(),addMessage(),updateNewMessage()------> App.js

Соответственно, чтобы избежать такой зависимости мы не импортируем из index.js функции, а внутри самого index.js при вызове компоненты App.js передаем в нее данные функции
с помощью props. По итогу циклической зависимости нет, а значит, ничего нам мешает применить тот же подход для цепочки:
state.js ------State-----> index.js
index.js ------renderEntireTree()------> state.js

Важно! На данном моменте рассматривается подход для передачи каких-либо данных вверх по цепи.

state.js (тут нужно получить функцию из index.js не импортируя её)
|
|
|
index.js

Т.е. для решения поставленной проблемы можно использовать следующий подход:
1. Создать внутри state.js пустую функцию renderEntireTree() (не та функция которая задана в index.js, т.к. она там и остается) с помощью let
2. Создать и экспортировать из state.js функцию subscribe(), принимающую в качестве параметра другую функцию (назовем параметр observer - наблюдатель) с функционалом
переопределения функции renderEntireTree() (пустой заглушки внутри state) на функцию которая передана в качестве параметра при вызове самой subscribe(observer), т.е.

export const subscribe = (observer) => {
    renderEntireTree = observer
}

3. На данном этапе мы экспортируем только из state.js вниз по цепи (из index.js ничего в state.js не экспортируется)
4. Экспортируем эту функцию также вниз по цепи от state.js к index.js

state.js
  |
  |
state
addPostIdea()
updateNewPostIdea()
addMessage()
updateNewMessage()

subscribe() - самый главный в данном уроке экспорт из state.js
  |
  |
  \/
index.js

5. Вызываем эту функцию внутри index.js и передаем в качестве параметра уже настоящую функцию renderEntireTree() (не заглушка, а нормальная функция рендера из index.js)
6. Теперь ввиду вызова этой функции с таким значением параметра, несмотря на то что функция вызвана в index.js ее выполнение происходит следующим образом:
    в index.js - sunbscribe(renderEntireTree)
    функция вызывается и присваивает лежащей внутри state renderEntireTree() (пустой) - значение, переданное через параметры, а именно нормальную функцию renderEntireTree()
    а значит внутри state renderEntireTree() (заглушка) переназначается на нормальную функцию и при этом мы не использовали импорты

Итог: мы избежали циклических импортов, но получили функцию внутри state.js

Еще раз:
Если нам нужен какой-либо объект (или функция) на верхних уровнях и мы не можем использовать импорты с целью избежать циклической зависимости:
1. На верхнем уровне, где нам нужена функция - создаем пустую функцию заглушку 
2. Создаем функцию subscribe(), принимающую в себя параметром другую функцию и переназначающую функцию заглушку на переданный параметр при вызове sunbscribe()
3. Передаем subscribe() по имеющейся цепочке вниз через props
4. Вызываем в нижнем уровне функцию subscribe и передаем в нее в качестве параметра ту функцию которую хотим получить наверху
5. subscribe(observer) имеет функционал изменения функции на верхнем уровне на observer, а значит хоть она и вызвана внизу, однако изменения совершает на верхнем уровне
6. Теперь после ее вызова внизу, наверху наша заглушка стала равно observer.

Весь данный функционал называется паттерн observer (на этом паттерне работают обработчики событий)

Для самостоятельного изучения: паттерн observer

Следующий важный шаг это объект store (ООП) (несмотря на то, что React и Redux - это фукнциональное программирование, мы все равно будем использовать элементы ООП)

// 36 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
До этого у нас был обычный (тупой) объект содержащитй только данные - state. Однако, несмотря на то, что React базируется не на объектно-ориентированном принципе 
программирования, а на функциональном подходе, тем не менее нам все равно иногда придется использовать "умные" объекты (объекты реализующие какой-то фунгкционал - обладающие
методами). В роли такого объекта может выступать:

let man = {
    name: "Egor",
    age: 23,
    sayName() {
        alert(this.name)
    }
}

У объекта также могут быть приватные свойства (начинающиеся с нижнего подчеркивания: _content) с которыми не стоит взаимодейтсвовать напрямую. Т.е., например, у нас есть 
следующий объект:

let page = {
    title: "Lalalalalala",
    _content: ``,

    setContent(value) {
        // Тут может быть другая логика
        this._content = value
    }

    getContent() {
        return this._content
    }
}

Почему иногда важно не взаимодействовать напрямую с свойством объекта? Потому что иногда простое присваивание page._content = '<div>Some text</div>'; просто переназначает
содержание, но часто бывают случаи, когда нам нужно реализовывать какую-то логику дополнительно при установлении контента как в нашем случае (например считать количество
изменений контента и что-то подобное). И в таком случае намного удобнее использовать page.setContent('<div>Some text</div>') ведь внутри данного метода мы можем реализовать
автоматически другую логику и ее не нужно писать при каждом изменении _content.

*
Догадка
Скорее всего это подводка к глобальному объекту store в котором функции обновления состояни (посимвольно) и добавления/удаления элементов из определенных массивов данных
буду интегрированы как set-еры, а значит сама структура хранения данных и работы с ними будет более структурирована. И не придется отдельно рядом с state создавать функции
изменяющие сам state, т.к. соответствующие функции будут лежать в одних и тех же объектах с теми данными с которыми они должны взаимодействовать. Соответственно, для 
обращения к данным внутри этого объекта будет использоваться ключевое слово this

Догадка подтвердилась, далее речь пойдет про store
* 

Теперь у нас есть store включающие следующие свойства и методы:

let store = {
    _subscriber() {
        console.log("No subscribers (observers)") // это заглушка
    },
    _state() {
        firstName: "alalalalalla",
        lastName: "ulululululul"
    }
    getState() {
        return this._state
    }
    subscribe(observer) {
        this._subscriber = observer
    }
    setFirstName(value) {
        this._state.firstName = value;
        this._subscriber()
    }
}

Тут мы уже видим логику похожу на то, что мы написали в прошлом уровке. Т.к. есть частные свойства (методы) с которыми пользователь не взаимодейтсвует на прямую, есть заглушка
_subscriber() которая после вызова subscribe(observer) становится равно той функции которую в нее передали при вызове в другом файле (а значит становится функцией из другого
файла, но при этом, не используя импорт)

Теперь и сами данные и логика их взаимодействия инкапсулируется внутри объекта store и взаимодействие с частными (приватными) свойствами осуществляется через get-еры и 
set-еры.
В дальнейших уроках мы будем изобретать свой store и развивать его, для того, чтобы понять, как работает ровно такой же store интегрированный в Redux.
Важно то, что при таком подходе нам не нужно постоянно экспортировать отдельные функции и увеличивать количество параметров у функции рендера страницы, т.к. мы можем передать
один лишь объект store и внутри него в нужный момент вызывать необходимые функции. 

// 37 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Изначально "упакуем" все данные и функции из файла state.js в новый объект store. Теперь нет необходимости экспортировать функции отдельно от данных и соответственно, нужно
отрефакторить часть кода, в том числе и внутри самого store, т.к. теперь для обращения к state нужно использовать this.
Теперь при прокидовании store._state через props возникает ошибка, т.к. нельзя напрямую обращаться к приватным свойствам объекта store, а значит нужно создать соответствующий
get-ер - getState(). Переименуем renderEntireTree() на _callSubscriber() (уведомить подпищика-пользователя (отрисовать UI)), с нижнем подчеркиванием, т.к. это тоже приватный
метод с которым нельзя взаимодейтсвовать напрямую.

Вылетает ошибка введу того, что когда при создании объекта сообщения или объекта нового поста мы обращаемся к this._state данная конструкция как бы говорит найди _state 
внутри этого нового объекта, а не глобального объекта store
Плюс ко всему методы которые мы перекидываем в props такие как addMessage(), addPostIdea() и другие могут вызываться в контексте других объектов (не store, а как в нашем
случае у props, например, в <Ideas /> метод addPostIdea() мы вызываем таким образом props.addPostIdea(), а значит ключевое слово this в данном случае равно не store, а 
props), а значит мы должны забиндить необходимый нам контекст.
Такое поведение обусловлено возможностью в JS вызывать методы одного объекта в контексте другого. Соответственно теперь при прокидовании методов через props нужно дописать
к выражению store.addPostIdea - .bind(store)
Важно отметить, что метод bind не вызывает метод, а просто возвращает идентичную функцию имеющую контекст объекта, который был передан в этот bind в качетсве параметра, 
т.е., как в нашем случае, возвращает функцию с закрепленным контекстом объекта store.

<App
    state={store.getState()}
    addPostIdea={store.addPostIdea.bind(store)}
    updateNewPostIdea={store.updateNewPostIdea.bind(store)}
    addMessage={store.addMessage.bind(store)}
    updateNewMessage={store.updateNewMessage.bind(store)}
/>

// 38 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Приватное свойство - свойство которым пользуется только сам объект store и методы определенные внутри него. Такие свойства не экспортируются и не вызываются в других 
компонентах. 
Ввиду того, что приложение может разрастаться и количество методов для работы в store будет увеличиваться, возникает проблема управления данными методами. Например, в 
большом проекте таких методов может быть порядка 200-300 штук, что довольно сильно усложнит навигацию по ним и их использование, а также передачу необходимых методов, 
например, при вызове компоненты <App />, ведь как показано в уроке выше нам приходится передавать каждый метод отдельной строкой, а значит при наличии 200 методов, мы как
минимум должны будем при вызове <App /> передать 200 строк кода чтобы поместить данные методы в props внутри <App />. Это неудобно.

Для решения этой проблемы был придуман универсальный метод dispatch(), который мы будем вызывать в любом случае, независимо от того, что мы хотим сделать в дочерних 
компоентах приложения (dispatch - отсылка, отправка + посылать, отсылать).
Для того чтобы метод dispatch() понимал какое именно дейтсвие ему необходимо выполнить мы всегда будем передавать в него некоторый объект action, который описывает
произведенное действие. Этот объект обязательно включает в себя поле type, например, со значением "ADD-POST". Сам же dispatch(action) с помощью проверок if else выбирает
необходимый участок кода который ему следует выполнить в зависимости от значения type, и выполняет его, а это значит, что саму реализацию метода (сам код) можно переписать
внутрь данного условия (блока if). Теперь когда мы выполним какое-то действие мы вызываем не сам метод addPostIdea(), а вызываем метод dispatch({type: "ADD-POST"}), который
внутри себя пробегается по всем условным выражениям и если находит соответствие с переданным type, выполнят код лежащий внутри блока, по которому отработало условие. 
Для того чтобы передать параметры методам которым необходимо получить какие-либо данные от UI чтобы работать с ними, нужно просто в передаваемый в dispatch() объект action
передать еще одно свойство с названием параметра который мы обрабатываем
Т.е.:
dispatch(action){
    // Метод без параметра
    if(action.type === "ADD-POST-IDEA"){
        // функционал метода addPostIdea()
        let newPostIdea = {
            id: this._state.profilePage.postIdeaData.length + 1,
            likesCount: 0,
            text: this._state.profilePage.newPostIdeaText,
        }
        this._state.profilePage.postIdeaData.push(newPostIdea)
        this._callSubscriber(this)
    }

    // Метод обрабатывающий какой-либо параметр (теперь обрабатывает свойство объекта)
    else if(action.type === "UPDATE-NEW-POST-IDEA"){
        // Функционал метода updateNewPostIdea(textOfNewPostIdea)
        this._state.profilePage.newPostIdeaText = action.textOfNewPostIdea (в этом свойстве мы и передаем в dispatch и внутренние методы само содержание нового поста)
        this._callSubscriber(this)
    }
}

Разные action с разным значением свойство type имеют разный набор дополнительных свойств т.к. позволяют вызвать разные методы работающие с разными данными.
Соотвтественно, теперь нам необходимо переписать все импорты и вызовы функций в дочерних компонентах при совершении каких-то действий пользователем, а также в тех методах
где мы использовали просто название параметра теперь обращаться к нему как к "action.названиеПараметра".

Теперь после изменения вызова всех методов работы с store (state) на dispatch(action), количество импортов уменьшилось, но при этом функционал работает также.
Важно отметить, что с помощью dispatch() мы оборачиваем только callback (методы или функции работы с store), а не сами данные, поэтому при изменении импортов нужно быть
внимательнее и не затереть одним dispatch'ем не только методы, но и какие-то данные, например, массив для отрисовки в компоненте.

Соответственно, теперь мы можем не просто перенести встроенные в store методы, а сделать их приватными добавив символ нижнего подчеркивания, с целью нераздувать сам 
метод dispatch(). Т.к. теперь достаточно в условных выражениях записывать не сам функционал метода который мы хотим вызывать, а всего лишь 
this._названиеМетода(action.названиеПараметра)
Но для этого в самом методе, должны обрабатываться не action.какоеТоСвойство, а параметры, как это было ранее. Этот подход хорош, но реализуем мы его позже.

// 39 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Помимо того, что мы создаем объекты action механически и есть высокий шанс допустить опечатку, из-за которой в будущем может случиться потеря данных или перестанет работать
функционал приложения, мы еще также нарушаем принцип Single Resposibility, т.к. помимо отрисовки и присвоения слушателей событий в компоненте, мы еще и создаем объекты 
action. Поэтому для того чтобы снять эту обязанность с компонента существует action creator. 

Action creator - это функция, которая создает необходимый объект и возвращает его. А значит записав результат вызова это функции в переменную action мы можем в метод 
dispatch() передавать просто название переменной

function actionCreate (text) {
    return {
        type: "UPDATE-NEW-POST-IDEA",
        textFromNewPostIdeaTextarea: text,
    }
}

let createdAction = actionCreate( createPostTextarea.current.value )
dispatch(createdAction)

Исходя из того, что данная функция создает объект для store, значит и осуществляться она должна внутри store.
*
Пока что слабо понимаю зачем, но нам необходимо для создания каждого объекта action в компонентах, создать функцию которая возвращает такой объект action и присваивает его
свойствам определенные значения, передаваемые в параметрах этой функции.
*

Однако на данный момент мы будет реализовывать эти функции внутри компонентов (что по идее также противоречит концепции Single Resposibility) 

* Скорее всего это было сделано просто для наглядности. Далее мы эти функции переносим в файл state.js и экспортируем чтобы импортировать в компоненте. *

После того как вынесли данные функции в state.js и экспоритровали, их необходимо импортировать в компоненте. 
Переносом данных функций в файл содержащий бизнес логику, мы уменьшили вероятность совершения ошибки при, например, передачи свойства type. Но для того чтобы еще сильнее
уменьшить вероятность ошибки или опечатки мы можем вынести значения свойства type в константные переменные и использовать не сырой текст внутри условных блоков метода 
dispatch() и внутри функций actionCreator(), а обращаться к одной и той же переменной в соответствующих местах, а значит вероятность ошибки снизится сильнее.
Поэтому создадим переменные содержащие в себе текс который равен значениям свойства type объектов action, которые мы передаем в dispatch() (это и есть action type)

let ADD_POST = "ADD-POST-IDEA";
let UPDATE_NEW_POST_IDEA = "UPDATE-NEW-POST-IDEA";
let ADD_MESSAGE = "ADD-MESSAGE";
let UPDATE_NEW_MESSAGE = "UPDATE-NEW-MESSAGE";

Action creator'ы теперь можно скомпоновать, убрав ключевое слово return и обернув возвращаемый объект круглыми скобками, для лучшей читаемости кода, т.е.:

вот эта запись:
export const addIdeaPostActionCreator = () => {
    return {
        type: ADD_POST_IDEA,
    }
}

 |
 |
 становится
 |
 |
 \/

вот этой:
export const addIdeaPostActionCreator = () => ({type: ADD_POST_IDEA})

Также подпись actionCreator в названии таких функций actionCreator'ов не используется, однако я пока таким образом рефакторить код не буду чтобы оставить наглядность.

// 41 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данный момент в объекте state у нас есть всего несколько ветвей приложения, например, таких как profilePage или dialogsPage и в методе dispatch() реализованы условные
конструкции выполняющие необходимый функционал для каждой ветви. Сейчас ветвей мало и код кажется читаемым, однако, часто в больших проектах намного больше ветвей приложения,
поэтому объект state и количество содержащейся в нем информации, методы которые мы реализуем для этой информации внутри dispatch(), а также функции создания объекта action
для каждого такого метода, очень сильно раздувают нашу бизнес логику и хранить их в одном файле весьма тяжело.

Чтобы решить данную проблему существует функция reducer.
Reducer - это чистая функция, которая принимает state и action, если нужно применяет принимаемый action к state и возвращает новый измененный state, а если не нужно то 
возращает тот же state, который пришел изначально в эту функцию.

Сейчас мы имеем довольно переплетенную логику (скриншот приложен в папку проекта), где:

1. UI в ответ на какое-то событие вызывает dispatch() внутри store и определенную функцию создания action передавая в нее всю необходимую информацию о действии и данные.
2. dispatch() принимает action и в зависимости от поля type выбирает какую часть кода выполнять (какой метод работы с store выбрать).
3. Данный метод выполняет изменение state (store) и вызывает функцию ререндера приложения.
4. Данная функция опираясь на новые данные в state перерисовывает UI.
5. Круг замыкается.
Однако ввиду того, что метод dispatch() весьма объемный, его составные части можно вынести в отдельные более мелкие функции для увеличения читаемости кода и его 
структурирования.

Теперь функционал условных блоков мы заменяем функцией reducer() которая также как и dispatch() принимает в качестве параметра объект action. Ввиду того, что данные файлы
лежат не в store и соответственно store не знает какому reducer подходит пришедший изначально в него action, а значит ему остается путем линейного перебора отправлять
action каждому reducer которые определены внутри dispatch() у объекта store.

Помимо этого, каждому reducer нужен определенный state, а значит нам не стоит передавать ту часть state с которой reducer не работает. Соответственно, внутрь каждого reducer
передаётся подчасть state, а сам reducer проверяет из полученного action от dispatch() нужно ли применить к данному куску state какую-то логику, исходя из полученного
action.

Далее если в условных выражениях внутри reducer отрабатывает условие, то выполняется какой-то метод модернизации части state, а если нет, то state возвращается без 
изменений и в итоге из результата вызова всех reducer по переданному action складывается новый объект NEWSTATE, на основании которого и вызывается функция ререндера 
приложения (скриншот данной структуры приложен к проекту).

Каждый reducer создается в новом файле внутри папки redux с соответствующим ветви приложения названием. После создания файлов всю логику из dispatch() нужно перенести в
соответствующие функции reducer. Важно отметить, что константы (action type) также нужно перенести внутрь файла с соответствующим reducer (но не внутрь самой функции)

Ввиду того, что мы вынесли из store логику методов преобразования state, то и обращаться к this теперь не имеет смысла. К тому же мы принимаем в reducer необходимую часть
state, а значит запись:

this._state.profilePage 
 |
 |
можно заменить на
 |
 |
 \/ 
state (название параметра принимаемого функцией reducer)

Важно отметить, что вызов функции ререндера теперь не наша ответственность, а значит мы должны удалить this._callSubscriber(this)
reducer в данном случае (преобразователь, а не понизитель) выполняет функцию преобразования state и возврата его с целью получить общую картину с измененными частями.

Теперь наши функции reducer готовы к использованию и нам остается просто воспользоваться ими внутри store в методе dispatch(), а значит данные reducer'ы нужно 
экспортировать (желательно подефолту, т.к. из файла мы больше ничего не экспортируем). Далее чтобы вызвать данные функции внутри dispatch() объекта store, их нужно 
импортирорвать и вызвать передав в каждый соотвествующую ветвь приложения (this._state.profilePage) и принимаемый методом dispatch() объект action, т.е. 

import profileReducer from "./profile-reducer";
import dialogsReducer from "./dialogs-reducer";
import navigationBlockReducer from "./navigation-block-reducer";

let store = {

    _state = {
        profilePage: ...,
        dialogsPage: ...,
        navigationBlock: ...
    }

    dispatch (action) {
        profileReducer(this._state.profilePage, action)
        dialogsReducer(this._state.dialogsPage, action)
        navigationBlockReducer(this._state.navigationBlock, action)
    }

}

А раз вызов функции profileReducer(this._state.profilePage, action) возвращает нам новый profilePage, значит внутри dispatch() мы сразу можем перезаписать свойство 
profilePage объекта state. Если также сделать у остальных вызовов функции dispatch() будет выполнять собирающую функцию и изменит весь state (т.е. создаст NEWSTATE из
скриншота).
Следовательно, после реализации данного функционала нам остается вызвать _callSubscriber(this) внутри самого метода dispatch() после переопределенния всех ветвей приложения

Проверок внутри reducer может быть много и при этом они являются взаимоисключающими, т.к. значение поля type может быть только одно, а значит конструкцию if else лучше 
переписать используя switch case.
Также важно не забыть перенести actionCreator'ы в соответствующие файлы reducer'ы и поменять пути импорта внутри компонентов, которые используют эти actionCreator'ы. Также
нужно отметить, что теперь из файла reducer экспортируется несколько различных функций, поэтому сама функция reducer экспортируется подефолту, а actionCreator'ы как модули

Теперь код стал намного более структурированным, т.к. dispatch() выполняет функцию объединения частей приложения, возвращаемых reducer'ами, перезаписывает state на результат
вызова данных reducer'ов и ререндерить само приложение, а reducer'ы хранят в себе всю логику взаимодействия с конкретной ветвью приложения.

На самом деле сейчас мы реализовали store который используется библиотекой Redux собсвтенноручно, а значит поняли подкаподные процессы, и следовательно, в следующих уроках
мы будем учится работать с самой библиотекой, а не разбираться как устроена подкапотка.

// 42 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Т.к. файл state.js явно давным давно выполняет функции не просто state, а целого store, то логичным будет его переименовать в store.js 
Redux - это отдельная библиотека, поэтому изначально ее нужно установить с помощью команды:

*
Устаревший вариант:
"npm i redux --save"

Запись "--save", как уже ранее упоминалось, создает запись зависимости в package.json, чтобы другие разработчики работающие с этим проектом могли быстро установить весь 
необходимый набор пакетов.

Правильным тоном будет останавливать проект перед установкой пакета поэтому также нужно остановить сервер с помощью "Ctrl + C" в терминале.
После установки пакета в файле package.json появится запись:
"redux": "^5.0.1",

Теперь мы можем работать с этой библиотекой. Redux предоставляет большое количество различного функционала, например, мы можем создать store вызвав функцию у модуля Redux
под названием createStore(). Для этого создадим новый файл redux-store и не будем удалять нами написанный store, чтобы можно было в него подглядывать когда возникнут вопросы
при работе со store, созданным с помощью Redux. Предварительно нам нужно импортировать данную функцию создания из пакета Redux с помощью команды:


import {createStore} from "redux";

И вызов данной функции вложить в переменную store:
let store = createStore()
*

*
Актуальный вариант:

"npm install @reduxjs/toolkit react-redux"

Redux обновился и теперь функцию createStore() импортируют из пакета react-redux, который в большинстве своем заменяет redux.

Документация Redux: 
Redux — это шаблон и библиотека для управления и обновления состояния приложения с помощью событий, называемых «действиями».
Redux Toolkit (также известный как «RTK» для краткости) — это наш официальный рекомендуемый подход для написания логики Redux. Пакет @reduxjs/toolkit окружает основной 
redux пакет и содержит методы API и общие зависимости, которые, по нашему мнению, необходимы для создания приложения Redux.

Важно понимать что приложение состоит из четырех основных частей:
1. Состояния (каких-то данных приложения)
2. Интерфейса (который благодаря React отрисовывается опираясь на состояние)
3. Действия (которое совершает пользователь, тем самым меняя состояние приложения и перерисовывая интерфейс)
4. Диспетчера который опираясь на содержание действия совершает определенные преобразования в состоянии (с помощью reducer'ов)

Поэтому локальные состояния (внутри самих компонентов) - это неэффективно, т.к. может возникнуть ситуация, когда нам нужно перерисовать состояние в разных частях 
приложения, но мы не можем этого сделать, т.к. состояние является локальным для конкретного компонента. Можно конечно поднять его по цепи к родительским элементам,
но гораздо проще вынести само хранилище состояний (данных приложения) и логику работы с ним в отдельный и независимый от UI блок, а для этого и создан Redux.
Он позволяет с помощью своих инструментов и набора правил реализовать данный блок состояния и функций управления им (BLL) обособленно от UI, но при этом в тесной связи
перерисовки приложения в ответ на измения состояния путем совершения действия пользователем.

Поэтому для создания store нужно:
    1. Установить пакет @reduxjs/toolkit с помощью команды: "npm install @reduxjs/toolkit"
    2. Импортировать функцию {configureStore} как модуль из данного пакета с помощью: "import { configureStore } from "@reduxjs/toolkit";"
    3. Вложить результат вызова функции в переменную store
*

import { configureStore } from "@reduxjs/toolkit";
let store = configureStore()

Также важно не забыть экспортировать сам store с помощью:
"exprot default store"

Теперь нам нужно заменить импорт в index.js где мы используем store чтобы пользоваться не нашим store, а redux'овским store. Однако после исправления импортов у нас ничего
не будет грузиться, т.к. наш store имел логику, а redux'овский store на данный момент пустой.
Важно отметить, что методы subscribe(), dispatch() и getState() - по умолчанию встроены в redux'овский store, а значит их вызовы внутри компонентов приложения переписывать 
не надо. Тем не менее, нам необходимо переписать логику, которая сидит в reducer'ах, но при этом необязательно переписывать сами reducer'ы, ведь мы можем просто отдать их
внутрь redux'овского store (те reducer'ы которые мы создали ранее).

На данном этапе для того, чтобы добавить reducer'ы внутрь store нам нужно их скомбинировать с помощью функции combineReducers(). Для этого надо передать объект, 
объединяющий в себе все reducer'ы, которыми мы пользуемся в данную функцию, и результат выполнения функции вложить в переменную reducers т.е.:

import { combineReducers, configureStore } from "@reduxjs/toolkit";

let reducers = combineReducers({
    profilePage: profileRecuder,
    dialogsPage: dialogsReducer,
    navigationBlock: navigationBlockReducer,
})

Важно не забыть предварительно также импортировать данную функцию из "@reduxjs/toolkit" и те самые reducer'ы, которые мы создавали ранее (которые мы и компануем с помощью 
combineReducers() ). Также важно понимать, что комбинируя reducer'ы мы присваиваем значение вызова каждого reducer'а полю объекта, которое и соответствует той части
state за которую отвечает конкретный reducer (как показано выше в коде)

Важно, что когда мы создаем хранилище с помощью функции configureStore(), она должна принимать в качестве параметра объект с свойством reducer, значение которого по сути
своей должно являться объектом скомбинированных reducer'ов, т.е. как в нашем примере, объектом reducers, а значит после объединения всех reducer'ов нам нужно выполнить 
следующий код:

let store = configureStore({
    reducer: reducers,
})

(Вместо обычного вызова configureStore() без передачи параметров)
Т.е. грубо говоря, configureStore() создает внутри себя state с набором свойств: profilePage, dialogsPage, navigationBlock - каждое из которых хранит определенные 
состояния конкретного блока приложения и изменяется соответствующим reducer'ом который представлен в качестве значения этого свойства нами в объекте reducers.
Однако на данном этапе ничего работать не будет, т.к. в нашем store у нас были данные внутри profilePage, dialogsPage, navigationBlock и они даже были структурированы и 
имели вложенности.
На данном этапе браузер будет ругаться ввиду того, что reducer'ы, которые мы скомпоновали будут возвращать undefined. Странно, ведь на момент загрузки страницы у нас даже 
не отображается UI через который можно совершить действие (отправить в dispatch() объект action) и как следствие, с помощью dispatch() вызвать reducer'ы. Дело в том, что
когда мы инициализируем приложение, т.е. запускаем первый раз, система Redux осуществляет самостоятельную настройку и проверяет работу reducer'ов, а значит вызывает их,
но ввиду того, что reducer всегда принимает какой-то state, а какой state должен принимать reducer на стадии настройки, Redux не знает и соответственно, не передает никакого,
а это, в свою очередь, значит, что раз входящий state = undefined, значит и выходящий state = undefined тоже.

Соответственно, чтобы исправить эту ошибку нам достаточно задать значение параметра state, обрабатываемого reducer'ом, по умолчанию. Для этого внутри файла с reducer'ом 
нужно объявить переменную initialState, которая и будет равна необходимой части state, которую мы раньше записывали в структуре _state: {...}

Например, для profileRecuder, initialState = profilePage = {
    postIdeaData: [
        { id: 1, likesCount: 7, text: "I'm pooping" },
        { id: 2, likesCount: 21, text: "Why don't we create an app" },
        { id: 3, likesCount: 14, text: "How to create a react app?" },
        { id: 4, likesCount: 52, text: "This's terribly difficult" },
    ],
    newPostIdeaText: "",
}

Теперь при попытке написать что-либо в textarea или впринципе создать какой-то action и поменять state вылетает ошибка: 

"Cannot read properties of undefined (reading 'getState')"

Это связано с тем, что когда мы писали свой store мы вручную при получении action вызывали reducer'ы и в конце их вызовов вызывали функцию ререндера из index.js. Однако
важно понимать, что теперь мы нигде не выполняем функционал перерисовки (ререндера) приложения. Да, мы передаем внутрь redux'овского store функцию renderEntireTree() с 
помощью импортирования store.subscribe() внутрь index.js, и вызывая эту функцию внутри index.js, передаем в неё в качестве параметра саму функцию renderEntireTree(), что
в свою очередь означает, что функция subscribe() вызывается внутри самого store.js и там выполняет функционал присвоения для _callSubscriber() значения функции 
renderEntireTree(), а значит мы избагем циклических зависимостей в импортах и получаем функцию ререндера внутри store (из index.js, при этом, имея уже обратный импорт
из store.js в index.js (самого объекта store)). Следовательно, когда мы вызываем внутри dispatch() функцию _callSubscriber() мы передаем в нее state, который был обновлен
вызовом reducer'ов перед вызовом самой _callSubscriber(store) (чтобы внутри функции renderEntireTree у store получить state).
На данном моменте, важно понимать, что redux'овский store когда вызывает функцию ререндера не передает в неё обновленный state (вообще ничего не передает), а значит нам 
нужно самостоятельно получить state внутри index.js при определении функции renderEntireTree() и когда мы передаем функцию с помощью store.subscribe(), мы должны не просто
передавать renderEntireTree(), а еще и прописать функционал для получения state внутри внутри store (т.к. _callSubscriber() находится в store и сам state меняется тоже 
внутри store) и вызова функции с переданным в качестве параметра полученным с помощью getState() объектом state. (Важно, что я на данном моменте не передаю state, передаются 
весь store, т.к. мне нужно передавать dispatch() только в определенные компоненты и забиндить ему контекст самого store)
Для этого необходимо при вызове функции subscribe() передать функцию которая не только присваивает _callSubscriber() значение renderEntireTree(), но и выполняет 
store.getState() и передает данные state внутрь renderEntireTree(). Т.е. в index.js нужно написать:

subscribe( () => {
    let updatedState = store.getState()
    renderEntireTree(updatedState)
} )

Т.е. _callSubscriber() = данной переданной анонимной функции.

_callSubscriber = () => {
    let updatedState = _state
    renderEntireTree(updatedState)
}

Однако важно понимать, что я передаю весь store в функцию ререндера, поэтому мне необязательно вызывать метод getState(), а для того чтобы передать объект store, нужно
не просто присвоить его значение, а сделать его клона с помощью функции structuredClone(store) которая возвращает клона объекта store (зачем именно это делать пока что 
непонятно).


// 43 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данном этапе важно понимать, что ввиду того, что мы вызываем dispatch() внутри UI компонентов, мы грубо говоря заставляем компоненту быть не только интрументом 
отображения текущего состояния, но и знать какие-то данные про store (что не совсем правильно). А значит, нам каким-то образом нужно решить проблему вызова dispatch() 
внутри компоненты.
Можно было бы вернуться к формату с наличием callback'ов, которые мы прокидываем из store, но и в этом случае всё равно должен оставаться какой-то компонент из UI, который
взаимоейтсвует со store и также сама компонента хранила бы в себе функционал store (как и в случае с dispatch()), а значит такой формат нам тоже не подходит. (Плюс ко всему
пришлось бы передавать очень много callback'ов внутрь компонентов, а значит, та проблема от которой мы пришли с помощью dispatch() все равно вернулась бы)

Чтобы решить данную проблему нам нужно определится с тем элементом приложения которому разрешено общатсья со store. Для такого взаимодействия со store как раз и существует
контейнерная компонента. В неё приходит store, а она уже внутрь дочки (презентационной компоненты) прокидывает необходимый state и функции для работы со store. Тут 
возникает вопрос, а каким образом поменялась система нашего взаимодейтсвия если мы все равно вызываем dispatch() внутри презентационной компоненты (ответ пока не ясен)?.
(Изображение с структурой данного подхода приложено в папку проекта)

Задача контейнерной компоненты просто отрисовать презентационную компоненту, передав в неё необходимые функции работы с store и сам state с которым работает эта компонента
(презентационная).

Ответ на предыдущей вопрос: 
Мы можем создать внутри контейнерной компоненты функции которые вызывают определенную логику из store для конкретного действия (например, для добавления поста). 
Затем эту функцию передать внутрь презентационной компоненты и вызвать ее при клике на кнопку "Add post", а значит, теперь презентационная компонента (дочка) не знает
и не работает с функциями store, а просто вызываем функцию контейнерной компоненты, которая как раз и вызывает функции работы с store. (Грубо говоря дочка не сама
покупает куклу в магазине, а говорит маме "команду" купитьКуклу(), а та в свою очередь идет в магазин и выполняет взаимодействие с магазином (store)) 

Теперь нужно перезаписать все импорты и прокидывать сам store до контейнерной компоненты, внутри которой его нужно разделять на необходимые детали для презентационной.
Это нужно сделать для всех ветвей приложения. 
! ВАЖНО: store теперь передается до всех дочерних компонентов до их контейнерных друзей, которые и занимаются расчлинением store. Это сделано для того, чтобы контейнерная
компонента могла работать с методами store (поэтмоу store и передается целиком).

Такой подход позволяет нам использовать презентационную компоненту в любом другом месте нашего приложения, т.к. она просто принимает callback'и и необходимый state и никак
не связана с store напрямую. А значит в другом месте приложения в нее могут быть переданы другие state и другое содержание ее callback'ов, а значит компонента становится
универсальной.
Важно понимать, что оборачивать контейнерной компонентой нужно только те презентационные компоненты, в которых мы выполняем какие-то действия с store, а не все компоненты
приложения. Т.е. внутри Ideas.jsx мы хотим взаимодействовать с store, а значит нам нужны callback'и из контейнерной компоненты, следовательно создаем ее, а вот внутри 
компоненты Profile.jsx мы не изменяем store никаким образом, а просто прокидываем данные, значит создавать контейнерную компоненту не нужно.

Теперь выполним тот же функционал для ветвей navigationBlock и dialogsPage нашего приложения.

// 44 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данный момент в нашем приложении store передается по всей цепочке компонентов через props, несмотря на то, что используется он в основном только в компонентах-листьях 
(нижние компоненты дерева приложения). Чтобы было меньше путаницы, хотелось бы сделать так, чтобы store передавался напрямую в необходимую компоненту, например, их App.js.
Такая возможность существует и реализуется она с помощью context API.

Данный подход можно реализовать с помощью создания какого-то контекста у родительской для всех компонентов - компоненты App и помещения туда самого объекта store. Если мы
создаем у родительской функции какой-то определенный контекст, значит он доступен для всех ее дочерних функций, а значит у всех дочерних для <App /> компонентов будет 
доступ к объекту store. (Для наглядности схема такого подхода добавлена в папку проекта)

Для того чтобы создать контекст, нам необходимо создать новый файл, управляющий контекстом (например, StoreContext.js), а именно, в папке "src" у модуля React вызвать 
функцию createContext(defaultValue) и передать в качестве параметра значение по умолчанию (null) и результат вызова данной функции вложить в переменную "StoreContext", 
а после экспортировать данную переменную по дефолту

let StoreContext = React.createContext(null)

А чтобы дочерние компоненты имели доступ к данному контексту, нам необходимо обернуть вызов дочерних компонентов в index.js, компонентом (тегом) 
<Context.Provider value={something} >, где something - те данные к которым мы хотим иметь доступ в дочерних компонентах, т.е. объект store.

<Context.Provider value={props.store} >
    <App />
</Context.Provider>

Т.е. в файле StoreContext.js мы просто создаем контекст, а внутри index.js присваиваем ему value={store}, предварительно импортировав сам StoreContext. 
Важно отметить, что для создания и работы с контекстом существует отдельная библиотека, которая делает все ранее описанное "под капотом" и в следующем уроке мы будем 
работать с ней, а не вручную писать ее логику.

Теперь можно удалить прокидование store через props и обращаться к store через созданный контекст из необходимых компонентов. Для того чтобы можно было обращаться к 
данному контексту внутри дочерних компонентов нужно использовать следующий синтаксис:

<StoreContext.Consumer>
    JSX-разметка презентационной компоненты (потребителя контекста)
</StoreContext.Consumer> 

Предварительно, конечно, необходимо импортировать данный компонент (тег).
Данный компонент принимает в себя функцию, а значит саму JSX-разметку презентационной компоненты необходимо возвращать данной функцией, а следовательно и оборачивать тоже.
Чтобы обернуть функцию внутри компоненты мы должны использовать фигурные скобки {...}, т.к. работаем внутри JSX с JS функцией, возвращающей JSX-разметку презентационной
компоненты
Т.е.:

<StoreContext.Consumer>
    {
        (store) => {
            return(
                JSX-разметка презентационной компоненты (потребителя контекста)
            )
        }
    }
</StoreContext.Consumer> 

Данная функция принимает в качестве параметра store (т.е. для каждого StoreContext.Consumer параметр приходящий в данный компонент (и внутреннюю функцию) равен тому 
объекту, который мы поместили в StoreContext value={...})

Теперь возникает логичный вопрос: "А как контейнерная компонента будет взаимодейтсовать с store если она его не получает с помощью props?". Ответ достаточно прост: нам
просто необходимо перенести логику из контейнерной комопненты в ту функцию которую принимает в себя компонент <StoreContext.Consumer> таСамаяФункция </StoreContext.Consumer>
и указать эту логику до возврата JSX-разметки, т.е. до ключевого слова return

<StoreContext.Consumer>
    {
        (store) => {
            *
                Логика контейнерной компоненты
            *

            return(
                JSX-разметка презентационной компоненты (потребителя контекста)
            )
        }
    }
</StoreContext.Consumer> 

Полноценный пример из кода:

function IdeasContainer() {
    return (
        <StoreContext.Consumer>
            {
                (store) => {
                    let localState = store.getState().profilePage

                    let addPostIdea = () => {
                        store.dispatch(addIdeaPostActionCreator());
                        store.dispatch(updateNewPostIdeaActionCreator(""));
                    }
                    let updateNewPostIdea = (textFromCreatePostTextarea) => {
                        store.dispatch(updateNewPostIdeaActionCreator(textFromCreatePostTextarea));
                    }

                    return (
                        <Ideas
                            addPostIdea={addPostIdea}
                            updateNewPostIdea={updateNewPostIdea}
                            state={localState}
                        />
                    )
                }
            }
        </StoreContext.Consumer>
    );
}

Теперь props ненужны, а значит мы можем стереть их обработку как параметра внутри контейнерной компоненты (однако внутри презентационной они всё еще нужны)
Такое "обертывание" в <StoreContext.Consumer> { () => { return(JSX) } } </StoreContext.Consumer> необходимо проделать для всех контейнерных компонентов, чтобы избавиться
от прокидования данных через props.

ВАЖНО: Внутри <StoreContext.Consumer> фигурные скобки должны идти с новой строки, а не на одной строке с вызовом компонента

Сейчас мы работаем в формате React ---> Redux, поэтому вынуждены разрабатывая на React заниматься Redux'овским функционалом (работать с store, создавать reducer, использовать
Context API и т.д.), однако для упрощения данных процедур существует специальная библиотека react-redux, которая оборачивает написанный нами функционал взаимодействия с 
Redux внутрь определенной функции connect(), о которой речь пойдет в следующих уроках. Т.е. мы будем учиться работать в формате: React ---> ReactRedux --connect--> Redux

!!! ОЧЕНЬ ВАЖНО -----------------------------------------------------------------------------------------------------------------------------------------------------------

Когда мы добавляем собственные reducer'ы при создании redux'овского store, мы не должны изменять исходное состояние внутри этих reducer'ов. Это связано с тем, что redux
автоматически использует функционал Immer (который работает с неизменямыми состояниями). Т.е. когда мы получаем какой-либо state при вызове reducer (в ответ на какой-то
action от пользователя) мы не должны изменять исходный объект state, а должны клонировать его в новый и дополнять или изменять уже состояние клона. Соответственно, ввиду
того, что объекты и массивы в JS изменяемы, мы должны клонировать их и использовать для этого:

* В объектах синтаксис:

return {
    ...state,
    свойствоState: action.payload
}

вместо:

    state.свойствоState = action.payload;
    return state;

------------------------------------------------

* В массивах синтаксис:

return {
    ...state,
    state.свойствоStateМассив: state.свойствоStateМассив.concat( action.payload ) // или метод slice() для другого функционала изменения массива
}

вместо
    state.свойствоStateМассив = state.свойствоStateМассив.push( action.payload );
    return state;

-----------------------------------------------

где action.payload = данные передаваемые из UI для изменения state на их основе 
concat() - не изменяет исходный массив, а создает копию этого массива и выполняет преобразования с ней
slice() - также не изменяет исходный массив и если его вызвать без аргументов просто копирует исходный

Из документации:

1. "Чтобы неизменно обновлять значения, ваш код должен создавать копии существующих объектов/массивов, а затем изменять эти копии"
2. "Одно из основных правил Redux заключается в том, что нашим редукторам никогда не разрешается изменять исходные/текущие значения состояния!"
3. "Есть несколько причин, по которым нельзя изменять состояние в Redux:
    - Это вызывает ошибки, такие как пользовательский интерфейс, который не обновляется должным образом и отображает последние значения;
    - Это затрудняет понимание того, почему и как было обновлено состояние;
    - Это усложняет написание тестов;
    - Это нарушает возможность правильно использовать «отладку путешествий во времени»;
    - Это противоречит духу и шаблонам использования Redux."
4. "Важнейшее правило неизменяемых обновлений заключается в том, что вы должны сделать копию каждого уровня вложенности, который необходимо обновить."

Полезная ссылка по данной теме из документации: https://redux-toolkit.js.org/usage/immer-reducers 

Пример исправления reducer для dialogsPage (неверный вариант закоментирован): 
const dialogsReducer = (state = initialState, action) => {
    switch (action.type) {
        case ADD_MESSAGE:
            let messageObject = {
                id: state.messagesData.length + 1,
                text: state.newMessageTextFromTextarea,
                isMyMessage: true,
            }

            // state.messagesData.push(messageObject);
            // state.newMessageTextFromTextarea = "";

            return {
                ...state,
                messagesData: state.messagesData.concat(messageObject),
                newMessageTextFromTextarea: "",
            }

        case UPDATE_NEW_MESSAGE:

            // state.newMessageTextFromTextarea = action.textFromNewMessageTextarea;

            return {
                ...state,
                newMessageTextFromTextarea: action.textFromNewMessageTextarea,
            };

        default:
            return state;
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// 45 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
На данный момент структура проекта выглядит следующим образом:

UI(React) ------> Store(Redux)(BLL)

Однако ввиду того, что store больше смахивает но ООПшный объект, а React работает с функциональным программированием (компоненты = функции), получается не совсем единая
структура, т.к. в ней намешан и функциональный и объектно-ориентированный подходы. Для решения этого вопроса была создана библиотека react-redux. Она выступает прослойкой
между UI(React) и BLL(Redux):

UI(React) ------> (React-Redux) ------> Store(Redux)(BLL)

Для чего она нужна? Она принимает и понимает функциональный подход React и на основе его запросов или каких-то действий, оптимизировано работает с store с применением
объектно-ориентированного подхода.

Изначально данную библиотеку необходимо установить с помощью "npm i react-redux --save"

В предыдущем уроке перед нами стоял вопрос передачи store через контекст и для этого мы создали свою компоненту StoreContext и (Provider) и с помощью неё обозначили 
компоненты которые будут иметь доступ к данному созданному контексту с лежащим внутри store. Затем для каждой контейнерной компоненты с помощью StoreContext.Consumer
и внутренней его функции, мы получили данные из store и отобразили их с помощью return (JSX-разметка презентационной компоненты), а также передали в данную функцию
логику взаимодействия с данным store. 

На данном этапе мы создаем для каждой презентационной компоненты - контейнерную, где используем определенные функции взаимодейтсвия с store и получаем определенное состояние
state. В библиотеке react-redux существует специальная функция создающая такую контейнерную компоненту более лаконичным образом. Для того чтобы создать контейнерную
компоненту нам необходимо:
1. Импортировать функцию connect() из библиотеки react-redux:

    import {connect} from "react-redux"

2. Вызов данной функции возвращает функцию, создающую презентационную компоненту, а значит мы можем сделать это с помощью следующего синтаксиса:

    const ComponentNameContainer = connect()()

где connect() возвращает функцию создающую контейнерную компоненту, а вторые скобки () вызывают функцию создания презентационной компоненты внутри контейнерной.

3. Данная функция создания презентационной компоненты принимает в качестве параметра импортированную презентационную компоненту, которую мы хотим отображать, 
т.е. синтаксис таков:

    const ComponentNameContainer = connect()( ComponentNamePresentation )

Но на данный момент может возникнут логичный вопрос: "А как контейнерная компонента поймёт какие функции взаимодейтсвия с store и какой state необходимо передать в 
презентационную компоненту?". Для того, чтобы решить поставленный вопрос нам необходимо настроить функцию СОЗДАНИЯ КОНТЕЙНЕРНОЙ КОМПОНЕНТЫ, т.е. connect()
Для этого нужно создать две функции, возвращающие объект, в файле где мы создаем контейнерную компоненту. Пусть это будут функции f1 и f2

let f1 = () => {
    return {}
}

let f2 = () => {
    return {}
}

Данные функции нужно передать в connect() в качестве параметров, т.е. connect(f1, f2)
Что это дает? Выражение connect(f1, f2)( ComponentName ) создает презентационную комопненту и с помощью функций f1, f2 передает в нее в качестве props возвращаемые
функциями f1 и f2 объекты, т.е. если бы 

let f1 = () => {
    return {
        a: 1,
    }
}

let f2 = () => {
    return {
        b: 2,
    }
}

то мы получили бы внутри презентационной компоненты props.a = 1 и props.b = 2
При этом важно понимать, что сами a и b регистрируются внутри контейнерной компоненты (т.е. внутри connect(f1, f2)), а вызываются внутри презентационной
Одна из этих функций отвечает за передачу state, а именно f1 = mapStateToProps, а другая отвечает за передачу функций взаимодейтсвия с store (callback'ов), т.е. 
f2 = mapDispatchToProps.

Теперь непонятно как нам передать те props, которые необходимы внутри презентационной компоненты. "a = 1" и "b = 2" это конечно хорошо, но нам надо передать, например,
объект dialogsPage в качестве state. Значит теперь функция отвечающая за состояния (f1) должна выглядеть так:

let f1 = () => {
    return {
        dialogsPage: {},
    }
}

В очередной раз возникает вопрос: "А как передать в данное свойство объекта тот самый state, необходимый нам в презентационной компоненте (т.е. 
store.getState().dialogsPage)?". 
Важно понимать, что функция connect(f1, f2) при вызове создает еще и контекст, и сама "под капотом" передает state (store.getState()) внутрь f1 и dispatch (store.dispatch)
внутрь f2. Таким образом, библиотека react-redux позволяет нам забыть об ООПшном объекте store. Мы теперь работает с помощью функции f1 с состоянием и с помощью функции
f2 с методом dispatch() (функционалом изменения состояния), а сами перерисовки, создание контекста и другое она берет на себя.

Теперь понятно, что внутри функции f1 мы должны обработать приходящий параметр state

let mapStateToProps = (state) => {
    return {
        dialogsPage: state.dialogsPage,
    }
}

Название mapStateToProps и mapDispatchToProps принято называть именно так по документации, несмотря на то, что их можно назвать как угодно и всё продолжит работать. 
Функцию mapDispatchToProps логичнее было бы назвать mapCallbacksToProps, но нужно понимать, что внутри всех callback'ов взаимодействующих внутри контейнерной компоненты
с store мы выполняем метод dispatch(), а значит такое название тоже подходит. (dispatch() принимает в себя результат вызова функции actionCreator находящейся внутри 
файла создания reducer, которая возвращает объект с полем type исходя, из которого reducer'ы вызываемые dispatch'ем и понимают необходимо ли им выполнять какие-либо 
преобразования store).

Аналогично, функция передачи callback'ов должна выглядеть так:

let mapDispatchToProps = (dispatch) => {
    return {
        callbackName: (text) => {
            dispatch( actionCreator(text) )
        },
    }
}

Реальный пример из проекта:

Старый синтаксис создания контейнерной компоненты:

function CreateMessageContainer() {
    return (
        <StoreContext.Consumer>
            {
                (store) => {
                    let localState = store.getState().dialogsPage.newMessageTextFromTextarea

                    let addMessage = () => {
                        store.dispatch(addMessageActionCreator())
                    };
                    let updateNewMessage = (text) => {
                        store.dispatch(updateNewMessageActionCreator(text));
                    };

                    return (
                        <CreateMessage
                            state={localState}
                            addMessage={addMessage}
                            updateNewMessage={updateNewMessage}
                        />
                    )
                }
            }
        </StoreContext.Consumer>
    );
}

Превращается в:

import { connect } from "react-redux"

let mapStateToProps = (state) => {
    return {
        state: state.dialogsPage.newMessageTextFromTextarea,
    }
};

let mapDispatchToProps = (dispatch) => {
    return {
        addMessage: () => {
            dispatch(addMessageActionCreator())
        },
        updateNewMessageActionCreator: (text) => {
            dispatch(updateNewMessageActionCreator(text))
        },
    }
};

const CreateMessageContainer = connect(mapStateToProps, mapDispatchToProps)( CreateMessage );

Второй вариант явно выглядит лаконичнее.
Важно отметить, что в внутрь функции создания презентационной компоненты мы передаем не саму компоненту как JSX-тег, а переменную в которой лежит ее логика, т.е.:

connect(mapStateToProps, mapDispatchToProps)(ComponentName)   (без треугольных скобок)

Важно понимать, что тот метод dispatch(), который приходит в функцию mapDispatchToProps() уже имеет забинженный контекст объекта store.
Соответственно, теперь мы можем удалить ненужный предыдущей синтаксис создания контейнерной компоненты и переписать таким образом все остальные компоненты.

Ремарка: connect() на создает контекст, она просто имеет к нему доступ, нам необходимо создать его самостоятельно с помощью библиотеки redux. Для этого надо импортировать
 из неё компоненту <Provider /> и обернуть в нее дочерние компоненты как мы делали это ранее с помощью StoreContext.Provider. 
 Теперь импорт: import StoreContext from './StoreContext'; нам не нужен. Т.е. внутри функции рендера приложения будет следующая запись:

<Provider value={store}>
    <App
        store={store}
    />
</Provider>

// 46 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Ранее я выяснил, что менять исходный state внутри reducer'ов нельзя, и нам необходимо возвращать из них копию преобразованного state. Когда мы копируем клонируем объект
"A" в объект "B" с помощью оператора "...", мы делаем это несовсем должным образом, ведь такое клонирование является поверхностым (неглубоким). Это означает, что в
копированный объект (т.е. "B") приходят те же поля что и в объекте "A", однако, ввиду того, что часть свойств клонируемого объекта может содержать в качестве значений
ссылки на другие объекты (т.к. в переменной не хранится сам объект, а всего лишь ссылка на него), эти свойства не клонируются и в новый объект добавляется то же значение,
но с ссылкой на объект лежащий в исходном объекте. 

Т.е. когда мы копируем таким образом объект:

let a = {
    name: "Egor",
    age: 23,
    address: {
        street: "Pushkina",
        house: "Kolotushkina",
    } 
}

в объект:

let b = {
    ...a
}

мы копируем только внешний (главный объект), т.к. мы создали в памяти с помощью {} новый объект и перезаписали в него свойства объекта "a", но ввиду того, что некоторые 
значения объекта "a" хранят ссылки на другие объекты, значит соответствующие свойства объекта "b" хранят ссылки на ТЕ ЖЕ САМЫЕ объекты, а значит когда мы их изменяем
мы меняем в памяти исходный объект "a", ведь он тоже ссылается на те же объекты которые отражены теперь в "b" 
Т.е.:

a.adress === b.adress // true

но при этом если мы перезапишем внутри объекта "b" свойство address на новый объект с помощью

b.address = {
    street: "Pushkina",
    house: "Kolotushkina",
}

и сравним "a.address" и "b.address" то, несмотря на то, что они внутри идентичны, мы все равно получим false, т.к. это разные ссылки ссылающиеся на разные объекты в памяти

a.address === b.address // false

Соответственно, если у нас для клонирования существует какой-то обширный объект с большим кол-вом вложенностей, то нам придется перезаписывать все внутренние объекты 
с помощью оператор "..." (spread), а именно, для трех вложенностей нам нужно будет сначала перезаписать общий объект, затем обратиться к его свойство и перезаписать его
на свойство копируемого объекта, затем обратиться к свойству объекта, который является свойство общего объекта и т.д. Очевидно, что это неудобно, но это необходимо
для концепции чистых функций и имьютабельности которые проповедует React, а значит нам нужно переписать логику внутри reducer'ов снова.

// 47 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Чистая функция - это функция, которая принимает данные и обязательно возвращает их, т.е. даже если в качестве данных передан пустой объект, она все равно должна вернуть 
что-то. Такое поведение называется детерменированностью, т.е. - процесс, исход которого полностью определен алгоритмом, значениями входных переменных и начальным 
состоянием системы.

Примеры чистых функций:
props ---> "functional component" ---> JSX 
(state, action) ---> "reducer" ---> state

Важным является то, что сколько бы раз мы не передавали одни и те же данные, функция должна возвращать всегда один и тот же результат. 
А это уже называется принципом иммутабельности, т.е. неизменения первоначального состояния.

Соответственно, когда работа чистой функции зависит от каких-то глобальных объектов (например, store) результат получаемый при вызове функции с одними и теми же данными 
может быть различным.

Именно из-за этого принципа, мы и должны сначала клонировать приходящий state и только после этого, возвращать копию приходящего state с внесенными в нее изменениями.

ВАЖНО: раньше мы перерисовывали все приложение с помощью функции renderEntireTree(store) и как оказалось это неэффективно (да подход с наличием VDOM оптимизирует этот
процесс, но все равно это неэффективно). Функция connect() "под капотом" сама выполняет subscribe() и в ответ на изменения store ререндерить только ту часть приложения, 
т.е. только ту компоненту, в которой мы выполнили изменения. Поэтому теперь, ввиду того, что все изменения store в проекте реализованы с помощью connect(), нам не нужно
перерисовывать приложение с помощью функции renderEntireTree(), а значит и присваивать _callSubscriber() значение renderEntireTree() с помощью вызова store.subscribe()
нам тоже не нужно, т.к. это за нас сделает connect() (и присвоит _callSubscriber() значение функции, которая перерисует только определенную область, в которой есть 
измененные данные (с помощью mapDispatchToProps) ). Такой подход более оптимизированный. Остается только удалить логику происвоения  _callSubscriber() значение 
renderEntireTree() с помощью store.subscribe() из файла index.js

Важно понимать, что когда в приложении какая-либо компонента вызывает функцию mapDispatchToProps(), т.е. происходят какие-либо изменения в state, автоматически 
вызываются все функции mapStateToProps() для перерисовки UI приложения. В них приходит новый объект state (локализованный) и сравнивается с предыдущим, исходя из этого,
каждая перерисовывает именну ту компоненту, для которой mapStateToProps() стала передавать изменившийся state. Т.е. если mapStateToProps() хранит в себе, например, 2 поля, 
объекта state и они после равны новому state, т.е. остались такими же как и были до этого, значит изменения затрагивают другую компоненту, а значит нет смысла 
перерисовывать данную. Так работают все функции mapStateToProps() приложения. Они, после любого изменения state, вызываются все вместе и проверяют соответствует ли 
предыдущее состояние новому и если да, то перерисовывают компоненту(ы), которые обрабатывают кусок измененного state(локальная перерисовка). 
Такое поведение также является подкапотным функционалом connect(). 

Теперь важно понимать, что данный принцип иммутабельности довольно коварный, ведь мы должны делать глубокое копирование для каждого state внутри reducer'ов и логики 
изменения состояния. Ведь если мы просто скопируем объект, но будем менять внутри лежащий массив, мы все равно будет менять исходный state, а значит сравнение state
и newState не будет иметь смысла, т.к. мы все равно (при поверхностном копировании) меняем state. Поэтому надо переписать логику изменения state внутри reducer'ов, 
используя глубокое копирование.

Именно поэтому в следующих примерах (как я раньше указал в заметке) мы используем не push, а concat для массивов ведь этот метот в отличие от push возвращает новый
массив:

return {
    ...state, (поверхностно копируем все свойства из state)
    messagesData: state.messagesData.concat(messageObject), (значение свойства - объект, значит используем глубокое копирование)
    newMessageTextFromTextarea: "", (значение свойства не объект - значит просто перезаписывается)
}

Если бы мы хотели не добавлять элементы, а удалять их из массива мы бы сначала делали глубокое копирование самого массива newArrayOfPosts = [...posts] и только после 
этого у "ксерокопии" вызывали методы splice(), pop(), shift()

Важное замечание: если мы не собираемся менять какой-либо объект (массив) внутри state, нам нельзя делать для него глубокое копирование, т.к. когда функция 
mapStateToProps() будет сравнивать данные объекты, она будет вынуждена перерисовать НЕЗИМЕНЕННУЮ часть state (например, какой-то массив), т.к. любой массив (объект) 
не равен любому другому массиву (объекту). Значит функция увидит изменение и перерисует неизмененную часть (что повредит производительности)

// 48 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
Чтобы изменить все совпадения в файле нужно
1. Выделить слово
2. Нажать Ctrl + F (выделяются все слова в текущем файле) 
3. Нажать Alt + Enter, теперь изменить можно все слова сразу.

Ввиду того, что когда мы копируем объект поверхностно внутрь другого объекта и после перезаписываем его свойство, например, какой-то массив всё работает так как надо. 
Если бы мы сначала перезаписали свойство, а только потом сделали копию с помощью ...state, то перезаписанное нами изначально свойство перезатерлось бы свойсвтом из 
объекта state. Поэтому важно выполнять все преобразования только после поверхностного копирования самого объекта

Теперь ввиду того, что connect() не перерисовывает неизменяемые части state мы можем копировать сам state внутри reducer, но за пределами switch(){}, т.к. для всех 
case'ов из конструкции switch(){} в любом случае придется создавать поверхностную копию state. При этом сами изменения state не нужно выполнять вне case, т.к. для 
определенных компонентов может быть неактуально глубокое копирование отдельных частей state, которые они не изменяют, а следовательно, перерисовка данных частей state
не будет выполняться. Выполним данный функционал для dialogsReducer. 
!!! ВАЖНО: на самом деле, не для всех case'ов нам надо создавать поверхнустную копию, т.к. default: возвращает тот же state, который мы передавали, поэтому для реальной
оптимизации лучше просто объявить переменную в которую мы будем копировать (внутри case'ов) исходный объект состояния, а сами копирования уже выполнять внутри условий
(внутри case'ов). Также переменную копии объекта state выгодно создавать за пределами switch(){} ввиду того, что внутри switch для всех case'ов блочная область видимости,
а значит созданная переменная внутри одного case видна и внутри другого, а значит, объявляя переменную копии внутри case, нам пришлось бы постоянно придумывать новое 
название. Теперь в логике каждого case необходимо просто добавлять stateCopy = { ...state, + ПРЕОБРАЗОВАНИЯ } (кроме default) и соотвтественно возвращать сам stateCopy
Однако при таком подходе очевидно, что переменная stateCopy может быть лишей ведь можно сразу после return объявить объект как мы делали это ранее и изменять его, исходя
из задуманного функционала.
*
Заметка не по теме:
Везде где мы используем метод map и возвращаем какую-то JSX разметку (компонент) для каждого элемента массива, нам необходимо данному компоненту в качестве props передать
обязательное свойство key={} равное как правило id того элемнента (объекта) массива из данных которого мы формируем компонент. Поэтому для всех методов map() нужно
написать даный функционал в нашем приложении (после этого все ошибки в консоли пропадут).
*

*
На будущее: нужно будет пофиксить отправку в компоненты всего state (для Ideas с помощью mapStateToProps() отправляем весь profilePage как state (props.state). Так быть 
недолжно, ведь даже если поменяются те части profilePage которыми мы не пользуемся внутри <Ideas /> мы все равно перерисуем т.к. state изменится и mapStateToProps() 
увидит это изменение. Принцип чистых функций: функция принимает только те данные с которыми работает, а profilePage в будущем будет содержать еще и информацию для 
<ProfileInfo />)
*

// 49 урок -----------------------------------------------------------------------------------------------------------------------------------------------------------------
В данном уроке мы будем создавать страницу поиска пользователей в нашем приложении. Для этого создадим отдельную папку Users для компонентов и будем работать внутри неё.

*
Заметка не по теме:
Я решил, что писать шаблонный код для всех reducer'ов каждый раз - весьма утомительная идея, поэтому создам свой сниппет для этого (заодно повторю создание сниппетов)
Для того чтобы создать свой сниппет:
1. Открыть параметры (шестеренка внизу слева)
2. Нажать "Пользовательские фрагменты кода" (User snippets)
3. Открыть файл "Существующие фрагменты кода" в появившемся окне (если есть другие сниппеты) или создать новый глобальный файл (если ранее сниппеты не создавались)
4. Создать сниппета
*

Изначально необходимо создать BLL для данного раздела приложения, т.к. в данном случае отрисовка будет опираться именно на хранящиеся данные. Поэтому начнем с создания
userReducer() и initialState к нему.

*actionCreator можно сокращать до AC*

В случае если возникает ситация, когда нам необходимо не удалять или добавлять элементы в массивы данных, а изменять конкретный элемент этого массива, нам необходимо,
также с помощью объекта action обработать процесс получения id данного элемента и использования его для того чтобы найти сам элемент в массиве данных внутри 
reducer.
Т.е. если мы меняем конкретный элемент массива, нам нужно передать идентификатор данного элемента внутрь reducer и там на основании этого идентификатора, найти нужный
элемент внутри массива данных.
Для таких целей можно использовать метод map(), который создает новый массив и использовать внутри его логику проверку на соответствие user.id с action.userId, т.е. на
соответствие айди необходимого к изменению пользователя с айди пользователей в массиве, и если данная проверка срабатывает, делать глубокую копию этого объекта user
меняя его необходимые поля, затем вернуть этого пользователя, а если проверка не отработала, просто вернуть пользователя.
Синтаксис return у case будет выглядить следующим образом:

return {

    ...state,

    users: state.users.map((user) => {

        if (user.id == action.userId) {
            return {
                ...user,
                followed: true,
            }
        }

        else {
            return user
        }

    })
}

Ввиду того, что мы подготавливаемся к работе с сервером, нам нужно реализовать еще один дополнительный actionCreator(). На данный момент, мы прописываем данные для
наших reducer'ов вручную, однако, в реальном проекте мы получаем их с сервера, а значит, нам нужно внутри reducer обработать ситуацию когда мы запрашиваем пользователей
с сервера (т.е. прописать отдельный case для получения в state пользователей с сервера). Его функционал будет заключаться в создании копии state и заполнению массива
пользователей результатом запроса на сервер, который мы будем передавать внутрь с помощью action.users (=[...]) нашему state (setUsersAC). Т.е.:

export const setUsersAC = (usersArray) => {
    return {
        type: UNFOLLOW,
        users: usersArray,
    }
};

А значит мы должны соответствующим образом обработать action созданный этим actionCreator() внутри самого reducer'а с помощью case: return{...}. Синтаксис будет таким:


case SET_USERS:
    return {
        ...state,
        users: state.users.concat(action.users)
    };

Важно заметить, что конкатенировать массив с помощью concat() с полученными пользователями не всегда верно, ведь может быть случай, когда изначально users
пуст, а значит undefined и следовательно, вызвав метод concat(action.users) у undefined мы получим ошибку (исправить это можно путём изначального присвоения state.users, 
в качестве значения, пустого массива). 
Также нужно понимать, что иногда нам необходим функционал постепенного отображения пользователей на странице, например, при клике
на кнопку "Show more", а значит нам нерезонно перетерать старый массив новым постоянно, нам выгоднее использовать concat() чтобы не создавать постоянно новый массив всё 
большего и большего размерас с одними и теми же данными (однако метод concat() возвращает новый массив, поэтому мы все равно по факту создаем новый массив на каждое 
изменение реализованное где action.type = SET_USERS)

Теперь создадим контейнерную компоненту для нашей презентационной компоненты <Users />
Важно также не забыть добавить внутрь функции combineReducers наш новый reducer, с целью создания внутри глобального state, блока usersPage под наши данные, т.е.:

let reducers = combineReducers({
    profilePage: profileRecuder,
    dialogsPage: dialogsReducer,
    navigationBlock: navigationBlockReducer,
    usersPage: usersReducer,
})

Теперь, когда мы выполнили данное дейтсвие и данной функцией combineReducers() добавлен объект (блок памяти) usersPage, который обслуживается usersReducer'ом, мы можем 
получить из контекста необходимый state внутри mapStateToProps() нашей контейнерной компоненты. 

const mapStateToProps = (state) => {
    return {
        users: state.usersPage.users
    }
};

А ввиду того, что мы создали внутри reducer'а логику добавления или удаления пользователя из друзей (follow и unfollow) мы можем передать внутрь презентационной компоненты
две callback функции, которые вызывают соответствующий actionCreator (followAC или unfollowAC) и получают, а затем передают в reducer внутрь switch(){} необходимые 
параметры для каждого actionCreator()

На данном этапе у нас польностью готова контейнерная компонента, а значит остается создать презентационную и обработать присылаемые контейнерной компонентой данные, а 
именно, список пользователей (для каждого пользователя вернуть карточку пользователя в списке (UserCard)). Создадим для этого новую компоненту <UserCard />

Важно: 
Когда мы итерируемся по массиву и задаем атрибут key={} для тегов JSX внутри которых лежат данные элементов данного массива, мы задаем этот атрибут исключительно
главному (внешнему тегу или компоненту), т.е.:

props.users.map((user) => {
    return (
        <li key={user.id}>
            lalalala
        </li>
    )
})

Если выполнять какие-либо функции преобразования state перед ключевым словом return{JSX} внутри презентационной компоненты, то мы можем получить ошибку, т.к. при отрисовке
компоненты, сначала будет вызываться функция изменения данных, а следовательно, компонента будет перерисовываться сразу после изменения данных и затем всё начинется 
сначала. Таким образом, образуется замкнутый круг, где компоненты просто не успевает отрисовать JSX разметку, а бесконечно занимается отправкой данных в state, в ответ
на эти изменения приложение перерисовывается и опять вызывает эту компоненты, которая опять вызывает изменение данных и так по кругу.

Напишем функционал для отображения пользователей с помощью функции props.setUsers(). Чтобы случайно не реализовать круговорот, описанный выше, поместим функцию вызова 
перед возвратом JSX-разметки с помощью return, но добавим проверку: "отрисовать пользователей с помощью setUsers, только если массив usersPage.users пустой", т.е.:

if (props.users.length === 0) {
    props.setUsers([
        { id: "1", avatarURL: "https//worldpodium.ru/sites/default/files/styles/400x400sc/public/gosha_rubchinskiy.jpg?itok=q5UPHzac", firstName: "Gosha", secondName: "Rubchinskiy", status: "I'm a big lover of potatoes", followed: true, location: { country: "Russia", city: "Moscow" } },
        { id: "2", avatarURL: "https//sun9-21.userapi.com/impg/E0ae8Uliu5G7iW-SkYcbW8vRGislwMNPaVdSMw/OoltFhFrKYI.jpg?size=800x800&quality=96&sign=6c927f6e823a4af40468e1ac54d0dd12&c_uniq_tag=1nZ2zwsZBqrlTYcgjRkIH3jppxBw3QjzjRNLcCSgAlU&type=album", firstName: "Alexey", secondName: "Konovalov", status: "Don't be afraid if you are one, be afraid if you are two", followed: false, location: { country: "Russia", city: "Chelyabinsk" } },
        { id: "3", avatarURL: "https//yk-resurs.ru/wp-content/uploads/3/4/8/348cc2bd09923386ef3cc2a39a4453d7.jpeg", firstName: "Ramhat", secondName: "Kazandaev", status: "UoyBoy", followed: true, location: { country: "Kazahstan", city: "Alma-Aty" } },
        { id: "4", avatarURL: "https//asiaplustj.info/sites/default/files/articles/333185/6.jpg", firstName: "John", secondName: "Smith", status: "Democracy", followed: false, location: { country: "USA", city: "Chicago" } },
    ])
}

*В примере выше убрал двоеточие после https для того, что убрать мелькающие превьюшки прогрузившихся аватарок в VS Code*

Однако теперь у нас в компоненте появляется побочный эффект (лишнее действие), т.к. презентационная компонента занимается не только отрисовкой, но и выполняет проверки.
Как решить данную проблему мы рассмотрим в следующих уроках, а пока данный блок if(){} необходим для корректной работы приложения.